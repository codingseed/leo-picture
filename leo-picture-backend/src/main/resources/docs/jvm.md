<img src="D:\在图片\JVM\006.png" style="zoom: 33%;" />

# JVM

<img src="D:\在图片\JVM\001.png" style="zoom: 50%;" />

<img src="D:\在图片\JVM\029.png" style="zoom:67%;" />



## JVM组成

### **什么是程序计数器?**

程序计数器:线程私有的，每个线程一份，无线程安全问题，内部保存的字节码的行号。用于记录正在执行的字节码指令的地址。

你能给我详细的介绍Java堆吗?

线程共享的区域:主要用来保存**对象实例**，**数组**等，当堆中没有内存空间可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常.

组成:年轻代+**老年代**

- **年轻代**被划分为三部分，**Eden**区和两个大小严格相同的**Survivor**区根据JVM的策略，在经过几次垃圾收集后，任然存活于Survivor的对象将被移动到老年代区间。
- **老年代**主要保存生命周期长的对象，一般是一些老的对象

<img src="D:\在图片\JVM\007.png" style="zoom: 67%;" /> <img src="D:\在图片\JVM\008.png" style="zoom: 67%;" />

**Jdk1.7和1.8的区别**

- 1.7中有有一个永久代，存储的是类信息、静态变量、常量、编译后的代码
- 1.8移除了永久代，把数据存储到了本地内存的元空间中，防止内存溢出

**线程私有的区域（每个线程独立一份）**：

**程序计数器（Program Counter Register）**

- 作用

  - 记录当前线程**正在执行的字节码指令的地址**（如果是 Native 方法，则为空）。
  - 是 JVM 中**唯一不会抛出 `OutOfMemoryError`** 的区域。

  意义：线程切换后能恢复到正确的执行位置。

  **Java 虚拟机栈（Java Virtual Machine Stack）**

  **本地方法栈（Native Method Stack）**

  - **作用**：为 JVM 调用 **Native 方法**（如 C/C++ 代码）服务。
  - **特点**：类似 Java 虚拟机栈，但服务于 Native 方法。
  - **异常**：同 Java 虚拟机栈（`StackOverflowError` 或 `OutOfMemoryError`）。

### **什么是虚拟机栈**

Java Virtual machine Stacks(java 虚拟机栈)

- **每个线程运行时所需要的内存，称为虚拟机栈**，先进后出。
- 每个栈由多个**栈帧**(frame)组成，存储**栈帧（Stack Frame）**，每个方法调用会创建一个栈帧
- 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

**垃圾回收是否涉及栈内存?**
垃圾回收主要指就是堆内存，当栈帧弹栈以后，内存就会释放

**栈内存分配越大越好吗?**
未必，默认的栈内存通常为1024k，栈帧过大会导致线程数变少

**方法内的局部变量是否线程安全?**

- 如果方法内局部变量没有逃离方法的作用范围，它是线程安全的
- 如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全

**什么情况下会导致栈内存溢出?**
栈帧过多导致栈内存溢出，典型问题:递归调用
栈帧过大导致栈内存溢出

#### **堆栈的区别是什么?**

栈内存一般会用来存储**局部变量**和**方法调用**，但堆内存是用来存储Java对象和数组的的。堆会GC垃圾回收，而栈不会。

栈内存是线程私有的，而堆内存是线程共有的。

两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常:

- 栈空间不足:java.lang.StackOverFlowError。
- 堆空间不足:java.lang.OutOfMemoryError。

### **能不能解释一下方法区?**

- **作用**：存储已被 JVM 加载的**类信息、常量、静态变量、即时编译器编译后的代码**等。
- 实现
  - **JDK 8 之前**：称为“永久代”（PermGen），是堆的一部分。
  - **JDK 8 及之后**：改为**元空间（Metaspace）**，使用**本地内存**（Native Memory），不再受 JVM 堆大小限制。
- **异常**：`OutOfMemoryError`（元空间不足时抛出）。

- 方法区(Method Area)是各个线程共享的内存区域
- **主要存储类的信息、运行时常量池**
- 虚拟机启动的时候创建，关闭虚拟机时释放
- 方法区域中的内存无法满足分配请求，则会抛出OutOfMemoryError: Metaspace

**直接内存（Direct Memory）**：

- **不属于 JVM 运行时数据区**，但受 JVM 间接管理（如 NIO 的 `ByteBuffer.allocateDirect()`）。
- **特点**：通过 Native 方法分配，受本机物理内存限制。
- **异常**：`OutOfMemoryError`（直接内存不足时抛出）。

<img src="D:\在图片\JVM\009.png" style="zoom: 50%;" />

### **常量池**

可以看作是一张表，虚拟机指令根据这张常量表**找到要执行的类名、方法名、字面量****等信息

```java
javap -v Application.class// 查看字节码结构(类的基本信息、常量池、方法定义)
```

<img src="D:\在图片\JVM\010.png" style="zoom: 50%;" />

### **运行时常量池**

常量池是***.class** 文件中的，当该类被加载，它的常量池信息就会放入**运行时常量池**，并把里面的**符号(#3等)地址**变为真实**内存地址**，僧是**方法区的子部分**

### 你听过直接内存吗?

<img src="D:\在图片\JVM\011.png" style="zoom: 50%;" />

- 并不属于JVM中的内存结构，不由JVM进行管理。是虚拟机的**系统内存**
- 常见于 **NIO 操作**时，用于数据缓冲区，分配回收成本较高，但读写性能高，不受JVM内存回收管理

## 什么是类加载器，类加载器有哪些

**类加载器**
JVM只会运行二进制文件，类加载器的作用就是将**字节码文件加载到JVM**中，从而让Java程序能够启动起来。

<img src="D:\在图片\JVM\012.png" style="zoom: 33%;" />

<img src="D:\在图片\JVM\005.png" style="zoom: 50%;" />

## **什么是双亲委派模型?**

加载某一个类，先**委托**上一级的加载器进行加载，如果上级加载器也有上级，则会继续向上委托，如果该类委托上级没有被加载，子加载器尝试加载该类。

- 双亲委派机制可以避免某一个类被重复加载,可以防止核心类被覆盖，错误加载。
- 为了安全，能防止恶意篡改核心API库。

## 说一下类装载的执行过程?

<img src="D:\在图片\JVM\013.png" style="zoom: 50%;" />

- **加载**:查找读取字节码class文件，将**字节码文件**转化为JVM内部的**运行时数据**存在方法区，同时会在堆内存创建一个代表类的.class对象，作为访问方法区中类数据的入口。
- **验证**:检查字节码的合法性。
- **准备**:**为类变量分配内存并设置类变量初始默认值**
  - static变量，分配空间在准备阶段完成(设置默认值)，赋值在初始化阶段完成。如：static int b= 10，准备阶段b为默认值0，初始化赋值后为10。
  - static变量是final的基本类型，以及字符串常量，值已确定，赋值在准备阶段完成
  - static变量是final的引用类型，那么赋值也会在初始化阶段完成
- **解析**:把类中的符号引用转换为JVM可使用的直接引用（内存地址）
- **初始化**:执行类的静态代码块和**静态变量的赋值**，执行初始化操作，**若该类有父类会先初始化父类**
- 使用:JVM 开始从入口方法开始执行用户的程序代码
- 卸载:当用户程序代码执行完毕后，JVM便开始销毁创建的Class对象。

## 垃圾回收

### 对象什么时候可以被垃圾器回收

**引用计数法**：一个对象被引用了一次，在当前的对象头上递增一次引用次数，如果这个对象的**引用次数为0**，那么该对象现在就是垃圾，代表这个对象可回收。

**可达性分析算法**：从 GC Roots 对象出发，遍历引用链。若对象与 GC Roots 间**无路径**，则判定可回收。

如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。

**定位垃圾的方式有两种：**

- 引用计数法(会有循环引用导致内存泄露)
  - <img src="D:\在图片\JVM\014.png" style="zoom: 50%;" />
- **可达性分析算法**
  - 从 GC Roots 对象出发，遍历引用链。若对象与 GC Roots 间无路径，则判定可回收。


### JVM 垃圾回收算法有哪些?

- 标记清除算法
- 复制算法
- 标记整理算法

**标记清除算法**
标记清除算法，是将垃圾回收分为2个阶段，分别是标记和清除：

1. 根据可达性分析算法得出的垃圾进行标记
2. 对这些标记为可回收的内容进行垃圾回收

<img src="D:\在图片\JVM\015.png" style="zoom: 50%;" />

优点:标记和清除速度较快
缺点:碎片化较为严重，内存不连贯的。里面可能存数组，数组是连续的内存，可能导致无法新的对象和数组。

**标记整理算法**（老年代垃圾回收器使用）

<img src="D:\在图片\JVM\016.png" style="zoom: 50%;" />

优缺点同标记清除算法，**解决**了标记清除算法的**碎片化**的问题，同时，标记压缩算法多了一步，对象**移动内存**位置的步骤，其**效率**也有有一定的**影响**。

**复制算法**（新生代使用）

将原有的内存空间一分为二，每次只用其中的一块,**正在使用的对象**复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收;无碎片，内存使用率低。

<img src="D:\在图片\JVM\017.png" style="zoom: 50%;" />

**优点:**

- 在垃圾对象多的情况下，效率较高
- 清理后，内存无碎片

**缺点:**

- 分配的2块内存空间，在同一个时刻，只能使用一半，内存**使用率较低**

## 说一下JVM中的分代回收

**分代收集算法**

在java8时，嗯，堆的区域划分在java8被分为了两份:新生代和老年代【1:2】

对于新生代，内部又被分为了三个区域：

- 伊甸园区Eden，新生的对象都分配到这里
- 幸存者区survivor(分成from和to)
- Eden区，from区，to区【8:1:1】

<img src="D:\在图片\JVM\018.png" style="zoom: 50%;" />

- 新创建的对象，都会先分配到eden区
- 当伊甸园内存不足，标记伊甸园与 from(现阶段没有)的存活对象
- 将存活对象采用复制算法复制到 to 中，复制完毕后，伊甸园和 from 内存都得到释放
- 经过一段时间后伊甸园的内存又出现不足，标记eden区域to区存活的对象，将存活的对象复制到from区
- 当幸存区对象熬过几次回收(最多15次)，晋升到老年代(幸存区**内存不足**或大对象会导致提前晋升)

**MinorGc、Mixed Gc、FullGC的区别是什么**

STW(Stop-The-World):暂停所有应用程序线程，等待垃圾回收的完成

- **MinorGc**【young GC】发生在新生代的垃圾回收，暂停时间短(STW)
- **Mixed Gc** 新生代 +老年代**部分区域**的垃圾回收，**G1 收集器特有**
- **FulGC**:新生代 +老年代**完整**垃圾回收(清空老年代和新生代的所有内存)，暂停时间长(STW)，应尽力避免。（内存不足时可能发生）

## 说一下JVM有哪些垃圾回收器?

在jvm中，实现了多种垃圾收集器，包括:

- 串行垃圾收集器
- 并行垃圾收集器
- CMS(并发)垃圾收集器
- G1垃圾收集器

**串行垃圾收集器**
**Serial**和**Serial Old**串行垃圾收集器，是指使用单线程进行垃圾回收，**堆内存较小**，适合个人电脑

- Serial 作用于新生代，采用复制算法
- Serial Old 作用于老年代，采用标记-整理算法

垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要暂停(STW)，等待垃圾回收的完成

**并行垃圾收集器**
Parallel（呸瑞喽） New和Parallel Old是一个**并行**垃圾回收器，**JDK8默认使用此垃圾回收器**

- Parallel New作用于新生代，采用复制算法
- Parallel Old作用于老年代，采用标记-整理算法

垃圾回收时，多个线程在工作，并且java应用中的所有线程都要暂停(STW)，等待垃圾回收的完成。

**CMS(并发)垃圾收集器**
CMS全称 Concurrent Mark Sweep，是一款**并发**的、使用**标记-清除**算法的垃圾回收器，该回收器是针对**老年代垃圾**回收的，是一款以获取**最短回收停顿**（短STW）时间为目标的收集器，主要应用于对响应时间敏感的场景（web应用）,停顿时间短，用户体验就好。其最大特点是在进行垃圾回收时，应用仍然能正常运行。

### 详细聊一下G1垃圾回收器

- 应用于新生代和老年代，**在JDK9之后默认使用G1**。
- 不再有新生代，老年代的区分
- 划分成多个区域，每个区域都可以充当 eden，survivor，old，humongous(忙给四)，其中 humongous 专为大对象准备

- 采用复制算法
- 兼顾响应时间与吞吐量

- 分成三个阶段:新生代回收(会触发STW)、并发标记（重新标记时也会STW）、混合收集

- 如果并发失败(即回收速度赶不上创建新对象速度)，会触发FuIlGC

<img src="D:\在图片\JVM\019.png" style="zoom:33%;" />

**Young Collection(年轻代垃圾回收)**

- 初始时，所有区域都处于空闲状态
- 创建了一些对象，挑出**一些**空闲区域作为**伊甸园区**存储这些对象
- 当伊甸园需要垃圾回收时，挑出**一个**空闲区域作为**幸存区**，用复制算法复制存活对象，需要暂停用户线程

- 随着对象的增加，伊甸园的内存又有不足
- 将伊甸园以及之前幸存区中的存活对象，采用复制算法，复制到新的幸存区，其中较老对象晋升至老年代

**Young Collection + Concurrent Mark(年轻代垃圾回收+并发标记)**

## 强引用、软引用、弱引用、虚引用的区别

**强引用**:只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收

<img src="D:\在图片\JVM\020.png" style="zoom:50%;" />

**软引用**:需要配合**SoftReference**使用，当垃圾多次回收，内存依然不够的时候会回收软引用对象

<img src="D:\在图片\JVM\020.png" style="zoom:50%;" />

**弱引用**:需要配合**WeakReference**使用，只要进行了垃圾回收，就会把弱引用对象回收

<img src="D:\在图片\JVM\021.png" style="zoom:50%;" />

**虚引用**:必须配合**引用队列**使用，被引用对象回收时，会将虚引用入队由 **Reference Handler** 线程调用**虚引用相关方法**释放直接内存

<img src="D:\在图片\JVM\023.png" style="zoom: 33%;" />

# **Java 中对象创建过程**

简略来说主要有以下几步：

1. **先检查类是否已加载**，当执行 `new Object()` 或反射、序列化等创建对象的指令时，JVM 首先检查这个类的符号引用是否在常量池中存在。若未加载则通过类加载器加载类信息。
2. **从堆中为对象分配内存空间**（从堆中），内存分配通常发生在堆上，基本数据类型（如 int、long、boolean 等）的值直接存储在栈上，当方法执行结束（栈帧弹出）时会自动释放
3. **内存空间初始化**（JVM 自动将分配的内存空间初始化为默认值：基本类型设为默认值，引用类型设为 null）
4. **设置对象头（Object Header Setup）**：为对象头填充信息（HotSpot 虚拟机）：**Mark Word**：存储对象哈希码、GC 分代年龄、锁状态标识等，**类元信息指针**：指向对象所属类的元数据（方法区中），确定对象的类型。**数组对象**额外包含「数组长度」信息。
5.  **执行实例初始化（Instance Initialization）**：**显式初始化**执行对象字段的直接赋值。**构造代码块初始化**：执行**类中的**构造代码块，**父类初始化**：若有父类，先执行父类的显式初始化和构造代码块
6.  **执行构造方法（Constructor Invocation）**：调用类的构造方法（`<init>()` 方法，由编译器自动生成），将开发者定义的初始化逻辑（如参数赋值、业务逻辑）应用到对象。
7.  **返回对象引用（Return Reference）**

## java对象一定分配在堆上吗

可以**通过 JVM 优化实现对象分配在栈上（逃逸分析）**：
如果 JVM 通过**逃逸分析**发现一个**对象**不会逃出**方法范围**（不会被外部引用），可能会将其优化为栈上分配，随方法结束自动释放。

# JVM 调优

## JVM 调优的参数可以在哪里设置参数值

- war包部署在tomcat中设置修改TOMCAT HOME/bin/catalina.sh文件

<img src="D:\在图片\JVM\024.png" style="zoom: 50%;" />

- jar包部署在启动参数设置通常在linux系统下直接加参数启动springboot项目

**nohup** :用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行参数

 **&** :让命令在后台执行，终端退出后命令仍旧执行。

![](D:\在图片\JVM\025.png)

## JVM 调优的参数都有哪些?

对于JVM调优，主要就是调整年轻代、老年代、元空间的内存空间大小及使用的垃圾回收器类型。

官网：https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html

- **设置堆空间大小**
- **虚拟机栈的设置**
- 年轻代中Eden区和两个Survivor区的大小比例
- 年轻代晋升老年代阈值
- **设置垃圾回收收集器**

**设置堆空间大小**
设置堆的初始大小和最大大小，为了防止垃圾收集器在初始大小、最大大小之间收缩堆而产生额外的时间，通常把最大、初始大小设置为相同的值

**堆空间设置多少合适?**

- 最大大小的默认值是物理内存的1/4，初始大小是物理内存的1/64
- 堆太小，可能会频繁的导致年轻代和老年代的垃圾回收，会产生stw，暂停用户线程
- 堆内存大肯定是好的，存在风险，假如发生了fullgc,它会扫描整个堆空间，**暂停用户线程的时间长**
- 设置参考推荐:尽量大，也要考察一下当前计算机其他程序的内存使用情况

## 说一下 JVM 调优的工具?

- 命令工具
  - jstack：查看java进程内线程的堆栈信息
  - jps：进程状态信息
  - **jmap**：查看堆转内存信息，内存使用情况
    - <img src="D:\在图片\JVM\026.png" style="zoom:67%;" />
    - format=b表示以hprof二进制格式转储Java堆的内存
    - file=<filename>用于指定快照dump文件的文件名
  - jhat ：堆转储快照分析工具
  - jstat：JVM统计监测工具

- 可视化工具

  - jconsole：用于对jvm的内存，线程，类的监控
    - 打开方式:java 安装目录 bin目录下 直接启动jconsole.exe 就行

  - VisualVM：能够监控线程内存情况，查看方法的CPU时间和内存中的对 象，已被GC的对象，反向查看分配的堆栈(只有JDK8有)
    - 打开方式:java 安装目录 bin目录下 直接启动 jvisualvm.exe就行

## 如何排查和解决 JVM 内存泄漏问题?有哪些常用的工具和方法?

**问题：**

- 老年代内存持续增长，触发频繁FuIIGC
- GC 后老年代内释放很少或不释放
- 应用响应变慢，最终可能抛出 OutOfMemoryError
- 堆内存使用率随时间呈线性上升趋势

嗯，要**先去确认内存泄露**：

监控 JVM 内存指标:通过工具观察堆内存各区域(Eden、Survivor、Old Gen)的使用趋势，判断是否存在内存无法释放的情况。

分析 GC 日志:开启 GC 日志(-XX:+PrintGCDetails -XX:+PrintGCTimeStamps)査看 Full GC 频率、耗时及内存释放情况。若 Full GC 后老年代内存占用仍很高，可能存在泄漏。

之后是**捕获内存快照**，在内存泄漏复现或接近 OOM 时，通过**jmp命令抓取堆内存快照**。

**再通过**VisualVM等工具分析快照，定位泄露对象，最后定位到代码修复内存泄露问题。

1. 获取堆内存快照dump
   1. 使用jmp命令：jmap -dump:format=b,file=heap.hprof(存储路径) pid(进程ID)
   2. 使用vm参数获取dump文件。有的情况是内存溢出之后程序则会直接中断，而imap只能打印在运行中的程序，所以建议通过参数的方式的生成dump文件。-XX:+HeapDumpOnOutOfMemoryError       -XX:HeapDumpPath=/home/app/dumps
2. VisualVM去分析dump文件
3. 通过查看堆信息的情况，定位内存溢出问题
4. 找到对应的代码，通过阅读上下文的情况，进行修复即可

<img src="D:\在图片\JVM\028.png" style="zoom:67%;" />

<img src="D:\在图片\JVM\027.png" style="zoom:67%;" />

## CPU飙高排查方案与思路?

1.使用top命令查看占用cpu的情况

2.通过top命令查看后，可以查看是哪一个进程占用cpu较高

3.使用ps命令查看进程中的线程信息

4.使用jstack命令查看进程中哪些线程出现了问题，最终定位问题
