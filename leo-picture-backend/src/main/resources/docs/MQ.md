# MQ(MessageQueue)



![](D:\在图片\MQ\01.png)



![](D:\在图片\MQ\02.png)



<img src="D:\在图片\MQ\04.png" style="zoom: 80%;" />

## RabbitMQ

RabbitMQ的整体架构及核心概念:

virtual-host:虚拟主机，起到**数据隔离**的作用

publisher:消息发送者

consumer:消息的消费者

queue:队列，存储消息

exchange:交换机，负责路由消息

<img src="D:\在图片\MQ\05.png" style="zoom: 80%;" />



### 同步调用

**同步调用的优势是什么?**

时效性强，等待到结果后才返回。

**同步调用的问题是什么?**
拓展性差
性能下降



### 异步调用

异步调用方式其实就是基于消息通知的方式，一般包含三个角色:

**消息发送者**:投递消息的人，就是原来的调用方

**消息代理**:管理、暂存、转发消息，你可以把它理解成微信服务器

**消息接收者**:接收和处理消息的人，就是原来的服务提供方

<img src="D:\在图片\MQ\03.png" style="zoom: 80%;" />



**异调用的优势是什么?**
耦合度低，拓展性强
异步调用，无需等待，性能好故障隔离，下游服务故障不影响上游业务缓存消息，流量削峰填谷

**异步调用的问题是什么?**
不能立即得到调用结果，时效性差不确定下游业务执行是否成功
业务安全依赖于Broker的可靠性





## spring整合MQ

### AMQP

<img src="D:\在图片\MQ\06.png" style="zoom: 80%;" />

步骤

<img src="D:\在图片\MQ\07.png" style="zoom: 67%;" />

<img src="D:\在图片\MQ\08.png" style="zoom: 67%;" />

<img src="D:\在图片\MQ\09.png" style="zoom: 67%;" />

<img src="D:\在图片\MQ\10.png" style="zoom: 67%;" />

### 任务模型

#### Work Queues

Work queues，任务模型。简单来说就是让多个消费者绑定到一个队列，共同消费队列中的消息。

<img src="D:\在图片\MQ\11.png" style="zoom: 67%;" />

<img src="D:\在图片\MQ\12.png" style="zoom: 67%;" />

<img src="D:\在图片\MQ\13.png" style="zoom: 67%;" />

**Work模型的使用**
多个消费者绑定到一个队列，可以加快消息处理速度
同一条消息只会被一个消费者处理
通过设置prefetch来控制消费者预取的消息数量，处理完一条再处理下一条，实现能者多劳



### 交换机

#### Fanout交换机

真正生产环境都会经过exchange来发送消息，而不是直接发送到队列，交换机的类型有以下三种
Fanout:广播
Direct:定向
Topic:话题

<img src="D:\在图片\MQ\14.png" style="zoom: 67%;" />



**交换机的作用是什么?**
接收publisher发送的消息
将消息按照规则路由到与之绑定的队列
FanoutExchange的会将消息路由到每个绑定的队列





#### Direct交换机

Direct Exchange 会将接收到的消息根据规则路由到指定的Queue，因此称为定向路由每一个Queue都与Exchange

设置一个BindingKey

发布者发送消息时，指定消息的RoutingKey

Exchange将消息路由到BindingKey与消息RoutingKey一致的队列

<img src="D:\在图片\MQ\15.png" style="zoom: 67%;" />

#### Topic交换机

<img src="D:\在图片\MQ\16.png" style="zoom: 67%;" />



**Direct交换机与Topic交换机的差异?**
Topic交换机接收的消息RoutingKey可以是多个单词，以.分割Topic交换机与队列绑定时的bindingKey可以指定通配符

#:代表0个或多个词

*：代表1个词



#### 声明队列和交换机

<img src="D:\在图片\MQ\17.png" style="zoom: 67%;" />

#### 消息转换器

**为什么要使用消息转换器**

1. **解决序列化和反序列化问题**

2. **提高消息的可读性和传输效率**

3. **增强系统的灵活性和扩展性**

4. **支持多种数据格式**

5. **提高系统的安全性和稳定性**

Spring的对消息对象的处理是出org.springframework.amqp.suppor.converter.MessageConverter来处理的。而默认实现是SimpleMessageConverter，基于JDK的ObjectOutputStream完成序列化。存在下列问题:
JDK的序列化有安全风险。
JDK序列化的消息太大
JDK序列化的消息可读性差



<img src="D:\在图片\MQ\18.png" style="zoom: 67%;" />



### MQ高级

#### 如何保证**发送者的可靠性**

**1.设置生产者重连可以避免网络波动导致的不可靠**
有的时候由于网络波动，
可能会出现客户端连接MO失败的情况。通过配置我们可以开启连接失败后的重连机制:

<img src="D:\在图片\MQ\19.png" style="zoom: 67%;" />

**注意**
当网络不稳定的时候，利用重试机制可以有效提高消息发送的成功率。不过SpringAMQP提供的重试机制是阻塞式的重试，也就是说多次重试等待的过程中，当前线程是被阻塞的，会影响业务性能。如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，请合理配置等待时长和重试次数，当然也可以考虑使用异步线程来执行发送消息的代码。

**2.MQ有生产者确认机制**
RabbitMQ了Publisher Confirm和Publisher Return两种确认机制。开启确机制认后，在MQ成功收到消息后会返回确认消息ACK回执给生产者。返回的结果有以下几种情况:

<img src="D:\在图片\MQ\20.png" style="zoom: 67%;" />

<img src="D:\在图片\MQ\21.png" style="zoom:50%;" />



<img src="D:\在图片\MQ\22.png" style="zoom: 50%;" />



SpringAMQP中生产者消息确认的几种返回值情况:
消息投递到了MO，但是路由失败。会return路由异常原因，返回ACK临时消息投递到了MQ，并且入队成功，返回ACK
持久消息投递到了MO，并且入队完成持久化，返回ACK其它情况都会返回NACK，告知投递失败如何处理生产者的确认消息?
**生产者确认需要额外的网络和系统资源开销，尽量不要使用**如果一定要使用，无需开启Publisher-Return机制，因为一般路由失败是自己业务问题
对于nack消息可以有限次数重试，依然失败则记录异常消息

#### **MQ的可靠性**

在默认情况下，RabbitMQ会将接收到的信息保存在内存中以降低消息收发的延迟。这样会导致两个问题:一旦MQ宕机，内存中的消息会丢失
内存空间有限，当消费者故障或处理过慢时，会导致消息积压，引发MQ阻塞

#### **消费者的可靠性**

##### 消费者确认机制

为了确认消费者是否成功处理消息，RabbitMO提供了消费者确认机制(Consumer Acknowledgement)当消费者处理消息结束后，应该向RabbitMQ发送一个回执，告知RabbitM0自己消息处理状态。回执有三种可选值:

ack:成功处理消息，RabbitMQ从队列中删除该消息

nack:消息处理失败，RabbitMQ需要再次投递消息

reject:消息处理失败并拒绝该消息，RabbitMQ从队列中删除该消息

<img src="D:\在图片\MQ\25.png" style="zoom: 50%;" />
SpringAMQP已经实现了消息确认功能。并允许我们通过配置文件选择ACK处理方式，有三种方式:

none:不处理。即消息投递给消费者后立刻**ack**，消息会立刻从MQ删除。非常不安全，不建议使用

manual:手动模式。需要自己在业务代码中调用api，发送**ack或reject**，存在业务入侵，但更灵活

auto:自动模式。SpringAMQP利用AOP对我们的消息处理逻辑做了环绕增强，当业务正常执行时则自动返回**ack**.

当业务出现异常时，根据异常判断返回不同结果:
◆如果是业务异常，会自动返回**nack**
◆如果是消息处理或校验异常，自动返回**reject**

<img src="D:\在图片\MQ\26.png" style="zoom: 50%;" />



##### 消费失败处理

**失败重试机制**

当消费者出现异常后，消息会不断requeue(重新入队)到队列，再重新发送给消费者，然后再次异常，再次requeue无限循环，导致mq的消息处理飙升，带来不必要的压力。我们可以利用Spring的retry机制，在消费者出现异常时利用本地重试，而不是无限制的requeue到mq队列:

```xml
spring:
	rabbitmq:
		listener:
			simple:
				prefetch:1
				retry:
					enabled:true #开启消费者失败重试
					initial-interval:1000ms#初始的失败等待时长为1秒
					multiplier:1 #下次失败的等待时长倍数，下次等待时长= multiplier * last-interval
					max-attempts:3#最大重试次数
					stateless:true #true无状态:false有状态。如果业务中包含事务，这里改为false
```

**失败消息处理策略**
在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有MessageRecoverer接口来处理，它包含三种不同的实现:

RejectAndDontRequeueRecoverer:重试耗尽后，直接reiect，丢弃消息。默认就是这种方式

ImmediateRequeueMessageRecoverer:重试耗尽后，返回nack，消息重新入队

RepublishMessageRecoverer:重试耗尽后，将失败消息投递到指定的交换机

<img src="D:\在图片\MQ\27.png" style="zoom: 50%;" />

<img src="D:\在图片\MQ\28.png" style="zoom: 50%;" />

**消费者如何保证消息一定被消费?**
开启消费者确认机制为auto，由spring确认消息处理成功后返回ack，异常时返回nack。
开启消费者失败重试机制，并设置MessageRecoverer，不设置的话会一直 重发。多次重试失败后将消息投递到异常交换机，交由人工处理

##### 业务幂等性

幂等是一个数学概念，用函数表达式来描述是这样的:f(x)=f(f(x))。在程序开发中，则是指同一个业务，执行一次或
多次对业务状态的影响是**一致的**。

<img src="D:\在图片\MQ\29.png" style="zoom: 50%;" />

**唯一消息id**
**方案一**，是给每个消息都设置一个唯一id，利用id区分是否是重复消息:

每一条消息都生成一个唯一的id，与消息一起投递给消费者

消费者接收到消息后处理自己的业务，业务处理成功后将消息ID保存到数据库

如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理。

<img src="D:\在图片\MQ\30.png" style="zoom: 50%;" />



方案二，是结合业务逻辑，基于业务本身做判断。以我们的业务为例:我们要在支付后修改订单状态为已支付，应该在修改订单状态前先查询订单状态，判断状态是否是未支付。只有未支付订单才需要修改，其它状态不做处理:

<img src="D:\在图片\MQ\31.png" style="zoom: 50%;" />



如何保证支付服务与交易服务之间的订单状态一致性?

首先，支付服务会正在用户支付成功以后利用MO消息通知交易服务完成订单状态同步。
其次，为了保证MQ消息的可靠性，我们采用了生产者确认机制、消费者确认、消费者失败重试等策略，确保消息投递和处理的可靠性。同时也开启了MO的持久化，避免因服务宕机导致消息丢失。最后，我们还在交易服务更新订单状态时做了业务幂等判断，避免因消息重复消费导致订单状态异常。
如果交易服务消息处理失败，有没有什么兜底方案?我们可以在交易服务设置定时任务，定期查询订单支付状态。这样即便MO通知失败，还可以利用定时任务作为兜底方案，确保订单支付状态的最终一致性，



#### **延迟消息**

延迟消息:生产者发送消息时指定一个时间，消费者不会立刻收到消息，而是在指定时间之后才收到消息。

延迟任务:设置在一定时间之后才执行的任务



**三种方案**

##### 死信交换机

当一个队列中的消息满足下列情况之一时，就会成为死信(dead letter):

1消费者使用basic.reject或 basic.nack声明消费失败，并且消息的requeue参数设置为false

2消息是一个过期消息(达到了队列或消息本身设置的过期时间)，超时无人消费

3要投递的队列消息堆积满了，最早的消息可能成为死信

如果队列通过dead-letter-exchange属性指定了一个交换机，那么该队列中的死信就会投递到这个交换机中。这个交
换机称为**死信交换机**(Dead LetterExchange，简称DLX)。

<img src="D:\在图片\MQ\32.png" style="zoom: 50%;" />



##### 延迟消息插件

RabbitMQ的官方也推出了一个插件，原生支持延迟消息功能。该插件的原理是设计了一种支持延迟消息功能的交换机
当消息投递到交换机后可以暂存一定时间，到期后再投递到队列。

<img src="D:\在图片\MQ\33.png" style="zoom: 50%;" />

发送消息时需要通过消息头x-delay来设置过期时间

<img src="D:\在图片\MQ\34.png" style="zoom: 50%;" />

##### 取消超时订单

设置30分钟后检测订单支付状态实现起来非常简单，但是存在两个问题:如果并发较高，30分钟可能堆积消息过多，对MQ压力很大
大多数订单在下单后1分钟内就会支付，但是却需要在MQ内等待30分钟，浪费资源



# 面试

<img src="D:\在图片\MQ\35.png" style="zoom:67%;" />

## RabbitMQ-如何保证消息不丢失

嗯!我们当时MYSQL和Redis的数据双写一致性就是采用RabbitMQ实现同步的，这里面就要求了消息的高可用性，我们要保证消息的不丢失。主要从三个层面考虑
第一个是开启生产者确认机制，确保生产者的消息能到达队列，如果报错可以先记录到日志中，再去修复数据
第二个是开启持久化功能，确保消息未消费前在队列中不会丢失，其中的交换机、队列、和消息都要
做持久化
第三个是开启消费者确认机制为auto，由spring确认消息处理成功后完成ack，当然也需要设置一定的重试次数，我们当时设置了3次，如果重试3次还没有收到消息，就将失败后的消息投递到异常交换机，交由人工处理

## RabbitMQ消息的重复消费问题如何解决的

嗯，这个我们还真遇到过，是这样的，我们当时消费者是**设置了自动确认机制**，当服务还没来得及给MQ确认的时候，服务宕机了，导致服务重启之后，又消费了一次消息。这样就重复消费了

因为我们当时处理的支付(订单|业务唯一标识)，它有一个业务的唯一标识，我们再处理消息时，先到数据库查询一下，这个数据是否存在，如果不存在，说明没有处理过，这个时候就可以正常处理这个消息了。如果已经存在这个数据了，就说明消息重复消费了，我们就不需要再消费了

其他解决方案：redis分布式锁、数据库的锁都是可以的

## RabbitMQ中死信交换机?(RabbitMQ延迟队列有了解过嘛)

延迟队列:进入队列的消息会被延迟消费的队列 。 延迟队列=死信交换机+TTL(生存时间)

死信交换机(Dead Letter Exchange，简称DLX)
如果该队列配置了dead-letter-exchange属性，指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机称为死信交换机

场景:超时订单、限时优惠、定时发布

<img src="D:\在图片\MQ\36.png" style="zoom:67%;" />

我们当时的xx项目有一个xx业务，需要用到延迟队列，其中就是使用RabbitMQ来实现的。
延迟队列就是用到了**死信交换机和TTL(消息存活时间)**实现的。如果消息超时未消费就会变成死信，在RabbitMQ中如果消息成为死信，队列可以绑定一个死信交换机，在死信交换机上可以绑定其他队列，在我们发消息的时候可以按照需求指定TTL的时间，这样就实现了延迟队列的功能了。
我记得RabbitMQ还有一种方式可以实现延迟队列，在RabbitMQ中安装一个死信插件，这样更方便一些，我们只需要在声明交互机的时候，指定这个就是死信交换机，然后在发送消息的时候直接指定超时时间就行了，相对于死信交换机+TTL要省略了一些步骤

## RabbitMQ如果有100万消息堆积在MQ，如何解决(消息堆积怎么解决)

当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到**队列存储**消息达到上限。之后发送的消息就会成为死信，可能会被丢弃，这就是消息堆积问题

解决消息堆积有三种种思路：

1. 增加更多消费者，提高消费速度
2. 在消费者内开启线程池加快消息处理速度
3. 扩大队列容积，提高堆积上限，采用惰性队列

惰性队列：在声明队列的时候可以设置属性x-queue-mode为lazy，即为惰性队列
基于磁盘存储，消息上限高
性能比较稳定，但基于磁盘存储，受限于磁盘I0，时效性会降低

<img src="D:\在图片\MQ\37.png" style="zoom:67%;" />

## RabbitMQ的高可用机制有了解过嘛

在生产环境下，我们当时采用的镜像模式搭建的集群，共有3个节点
·镜像队列结构是一主多从(从就是镜像)，所有操作都是主节点完成，然后同步给镜像节点

主宕机后，镜像节点会替代成新的主(如果在主从同步完成前，主就已经宕机，可能出现数据丢失)

嗯，熟悉的~
我们当时项目在生产环境下，使用的集群，当时搭建是镜像模式集群，使用了3台机器。
镜像队列结构是一主多从，所有操作都是主节点完成，然后同步给镜像节点，如果主节点宕机后，镜像节点会替代成新的主节点，不过在主从同步完成前，主节点就已经宕机，可能出现数据丢失

### 那出现丢数据怎么解决呢?

我们可以采用仲裁队列，与镜像队列一样，都是主从模式，支持主从数据同步，**主从同步基于Raft协议**，强一致。
并且使用起来也非常简单，不需要额外的配置，在声明队列的时候只要指定这个是仲裁队列即可
