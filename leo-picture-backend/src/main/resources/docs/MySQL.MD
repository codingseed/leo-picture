 ![](D:\在图片\MySQL\001.png)

# B+树

**B+树叶子节点与数据页的关系**

- **叶子节点 = 数据页**： InnoDB 中，B+树的**每个叶子节点就是一个物理存储单元，即一个数据页（16KB）**。页是 InnoDB 磁盘管理的最小单位，所有数据（包括索引和行记录）都存储在页中。

- 数据页内容

  每个叶子节点的数据页可能包含：

  - **用户数据**：表中的实际行记录（对于聚簇索引）。
  - **索引键 + 主键**：对于二级索引（非聚簇索引），叶子节点存储的是索引键和对应的主键值。
  - **页头/页尾信息**：如页类型、前后页指针（双向链表）、校验和等元数据。

**2. 数据页的默认大小（16KB）**

- **默认配置**： InnoDB 的页大小默认为 **16KB**（可通过参数 `innodb_page_size` 调整，但通常不建议修改，因为会影响性能兼容性）。

- 为什么是 16KB？

  - 平衡 I/O 效率与内存利用率

    - 较大的页（如 32KB）可能减少磁盘 I/O 次数，但会浪费内存（尤其是随机访问时）。
    - 较小的页（如 4KB）会增加 I/O 次数（更多页需要加载）。
    - 16KB 是经验证的最佳折中方案。
    
  - **与文件系统块大小对齐**： 现代文件系统（如 ext4、NTFS）的块大小通常为 4KB，16KB 是 4KB 的整数倍，可减少读写碎片。

**3. 叶子节点的存储细节**

**(1) 聚簇索引（Clustered Index）的叶子节点**

- **存储完整行数据**： 每行记录（Row）直接存储在叶子节点页中（即“索引即数据”）。

- 页内结构

  ：

  - **行记录**：按主键顺序存储，通过**单向链表**连接（逻辑连续，物理可能分散）。
  - **页目录（Page Directory）**：对行记录做稀疏索引（类似跳表），加速页内查找（二分查找）。

**(2) 二级索引（Secondary Index）的叶子节点**

- **存储索引键 + 主键值**： 叶子节点不存完整行数据，而是存储索引列的值和对应的主键（回表查询时需要根据主键回到聚簇索引查找完整数据）。

**(3) 页间连接**

- **双向链表**： 所有叶子节点通过双向链表连接（按主键或索引键排序），支持范围查询（如 `WHERE id BETWEEN 10 AND 20`）。

# 如何分析慢SQL？

![](D:\在图片\MySQL\002.png)

如果一条sql执行很慢的话，我们通常会使用mysql自动的执行计划explain来去查看这条sql的执行情况，比如在这里面可以通过key和key_len检查是否命中了索引，如果本身已经添加了索引，也可以判断索引是否有失效的情况，第二个，可以通过type字段查看sql是否有进一步的优化空间，是否存在全索引扫描或全盘扫描，第三个可以通过**extra建议**来判断，是否出现了回表的情况，如果出现了，可以尝试添加索引或修改返回字段来修复。

# 索引

**了解过索引吗?(什么是索引)**

索引(index)是帮助MySQL高效获取数据的**数据结构(有序)**。在数据之外，数据库系统还维护着满足特定査找算法的数据结构(B+树)，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级查找算法这种数据结构就是索引。

**面试回答：**

嗯，索引在项目中还是比较常见的，它是帮助MySQL高效获取数据的数据结构，主要是用来提高数据检索的效率，降低数据库的I/O成本，同时通过索引列对数据进行排序，降低数据排序的成本，也能降低了CPU的消耗。

# 数据结构对比

B+Tree是在BTree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构

B树与B+树对比:

- B 树每个节点都存储了**完整的数据**，而 B+ 树非叶子节点仅存储 key 和指针，完整数据存储在叶子节点。这使得 B+ 树可以在**内存中存放更多索引页**，减少**磁盘查询次数**。
- **B+ 树叶子组成了链表，便于区间查找，而 B 树只能每一层遍历查找，所以查询效率B+树更加稳定。**

B+树优点：

**树的高度不会像红黑树一样增长不会过快，使得查询磁盘的 I/O 次数减少**：

B+ 树是一种自平衡树，每个叶子节点到根节点的**路径长度**相同，**阶数更多**，**路径更短**。查找、插入、删除等操作的时间复杂度为 O(log n)，能够保证在大数据量情况下也能有较快的响应时间。

磁盘读写代价B+树更低，非叶子节点只存储指针，叶子阶段存储数据

**B+树便于扫库和区间查询，叶子节点是一个双向链表**

**面试回答：**

**索引的底层数据结构了解过嘛?**

MySQL的默认的存储引擎InnoDB采用的B+树的数据结构来存储索引，选择B+树的主要的原因是:第一阶数更多，路径更短，第二个磁盘读写代价B+树更低，非叶子节点只存储指针，叶子阶段存储数据，第三是B+树便于扫库和区间查询，叶子节点是一个双向链表

**B树和B+树的区别是什么呢?**

第一:在B树中，非叶子节点和叶子节点都会存放数据，而B+树的所有的数据都会出现在叶子节点，在查询的时候，B+树查找效率更加稳定
第二:在进行范围查询的时候，B+树效率更高，因为B+树都在叶子节点存储，并且叶子节点是一个双向链表

# 详细描述一条 SQL 语句在 MySQL 中的执行过程。

1. 先通过**连接器**校验权限
2. 利用**分析器**进行 SQL 语句的词法分析和语法分析，构建**解析树**
3. 使用**优化器**选择合适的索引和**表连接顺序**，最终选择一个最佳的执行计划
4. 利用**执行器**，调用引擎层查询数据，返回结果集给客户端

# 什么是聚集索引，什么是二级索引(非聚集索引)

![](D:\在图片\MySQL\003.png)

聚集索引选取规则:
如果存在主键，主键索引就是聚集索引。
如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引。
如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。

聚簇索引(聚集索引):数据与索引放到一块，B+树的叶子节点保存了整行数据，有且只有一个

非聚簇索引(二级索引):数据与索引分开存储，B+树的叶子节点保存对应的主键，可以有多个

# 什么是回表?

当我们所查询的列从二级索引中找不到具体的键值时，通过二级索引找到对应的主键值，在通过主键值到聚集索引中查找整行数据，这个过程就是回表

# 知道什么叫覆盖索引嘛 ?

覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到

**覆盖索引是指查询使用了索引，且返回的列在索引中全部能够找到**

使用id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。

如果返回的列中没有创建索引，有可能会触发回表查询，尽量避免使用select*

# MYSQL超大分页怎么处理?

超大分页一般都是在数据量比较大时，我们使用了imit分页查询，并且需要对数据进行排序，这个时候效率就很低，我们可以采用**覆盖索引和子查询**来解决
先**分页**查询数据的id字段，确定了id之后，再用子查询来过滤，只查询这个id列表中的数据,
因为查询id的时候，走的覆盖索引，所以效率可以提升很多

# 常见的索引创建原则有哪些?

嗯，这个情况有很多，不过都有一个大前提，就是表中的数据要超过10万以上，我们才会创建索引，并且添加索引的字段是查询比较频繁的字段，一般也是像作为查询条件，排序字段或分组的字段这些。

- **数据量较大，且查询比较频繁的表**
- **常作为查询条件、排序、分组的字段**
- **选择区分度高的列(如 user id)**
- **尽量联合索引要遵循最左匹配原则，**
- **要控制索引的数量**

还有就是，我们通常创建索引的时候都是使用**复合索引**来创建，一条sql的返回值，尽量使用覆盖索引，如果字段的区分度不高的话，我们也会把它放在组合索引后面的字段。
如果某一个字段的内容较长，我们会考虑使用前缀索引来使用，当然并不是所有的字段都要添加索引，这个索引的数量也要控制，因为添加索引也会导致新增改的速度变慢。

# 什么情况下索引会失效?

嗯，这个情况比较多，我说一些自己的经验，以前遇到过的
比如，索引在使用的时候**没有遵循最左前缀匹配原则**，第二个是，**模糊查询**，如果**%号在前面**也会导致索引失效。如果在添加索引的字段上进行了**运算操作**或者**类型转换**也都会导致索引失效。
我们之前还遇到过一个就是，如果使用了**复合索引，中间使用了范围查询**，右边的条件索引也会失效A所以，通常情况下，想要判断出这条sql是否有索引失效的情况，可以使用explain执行计划来分析

**最左前缀匹配原则**：因为联合索引在 B+ 树中的排列方式遵循“从左到右”的顺序，例如联合索引` (first_name, last_name, age)` 会按照 `(first_name, last_name, age) `的顺序在 B+ 树中进行排序，MySQL 在查找时会优先使用 `first_name` 最左侧索引作为匹配依据，然后依次使用 `last_name` 和 `age`。因此，组合索引能够从左到右依次高效匹配，**跳过最左侧字段会导致Mysql无法利用该索引**。

## 索引下推(ICP，5.6+)

WHERE 条件在**存储引擎层**过滤，减少回表次数

# sql的优化的经验,你平时对sql语句做了哪些优化呢?

嗯，这个在项目还是挺常见的，当然如果直说sql优化的话，我们会从这几方面考虑，比如建表的时候、使用索引、sql语句的编写、**主从复制**，**读写分离**，还有一个是如果量比较大的话，可以考虑分库分表

sql语句优化也有很多，比如SELECT语句务必指明字段名称，不要直接使用select*，还有就是要注意SQL语句避免造成索引失效的写法;

如果是**聚合查询**，尽量用union all代替union，union会多一次过滤，效率比较低;

如果是**表关联**的话，尽量使用innerjoin，不要使用用left_join和right_join，如必须便一定要以小表为驱动

# 事务的特性是什么?可以详细说一下吗?

原子性( Atomicity )
一致性( Consistency)
隔离性( lsolation)
持久性( Durability)

这个比较清楚，ACID，分别指的是:原子性、一致性、隔离性、持久性;

我举个例子A向B转账500，转账成功，A扣除500元，B增加500元，原子操作体现在要么都成功，要么都失败。

在转账的过程中，数据要一致，A扣除了500，B必须增加500

在转账的过程中，隔离性体现在A像B转账，不能受其他事务干扰

在转账的过程中，持久性体现在事务提交后，要把数据持久化(可以说是落盘操作)

# 并发事务带来哪些问题?

我们在项目开发中，多个事务并发进行是经常发生的，并发也是必然的，有可能导致一些问题

第一是脏读，当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时**另外一个事务**也访问了这个数据，因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。

第二是不可重复读:比如在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务**两次读取的数据可能不太一样**。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。

第三是幻读(Phantom read):幻读与不可重复读类似。它发生在一个事务(T1)读取了几行数据,接着另一个并发事务(T2)插入了一些数据时。在随后的查询中，第一个事务(T1)就会发现**多了些原本不存在的记录**，就好像发生了幻觉一样，所以称为幻读。

# 怎么解决这些问题呢?MySQL的默认隔离级别是?

解决方案是对事务进行隔离
MySQL支持四种隔离级别，分别有:
第一个是，未提交读(read uncommitted)它解决不了刚才提出的所有问题，一般项目中也不用这个。

第二个是读已提交(read committed)它能解决脏读的问题的，但是解决不了不可重复读和幻读

第三个是可重复读(repeatable read)它能解决脏读和不可重复读，但是解决不了幻读，这个也是mySql默认的隔离级别。

第四个是串行化(serializable)它可以解决刚才提出来的所有问题，但是由让是事务串行执行的，性能比较低。

所以，我们一般使用的都是mysql默认的隔离级别:可重复读

# undo log和redo log的区别

其中redo_log**重做日志**，记录的是数据页的**物理变化**，是固定大小的环形日志，主要用于**崩溃恢复**。它可以帮助 InnoDB 在崩溃后通过日志重做未写入数据页的数据修改，从而确保数据的**持久性**。

而undo_log不同，它主要记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据，比如我们删除一条数据的时候，就会在undo log日志文件中新增一条delete语句，如果发生回滚就执行逆操作;
redo log保证了事务的持久性，undo_log保证了事务的原子性和一致性

# 好的，事务中的隔离性是如何保证的呢?(你解释一下MVCC)

事务的隔离性是由**锁**和mvcc实现的。

锁是：**“间隙锁”（Gap Lock）和“临键锁”（Next-Key Lock）**

**间隙锁（Gap Lock）**：

- 它锁住的是索引记录之间的“间隙”，或者第一个索引记录之前/最后一个索引记录之后的“间隙”。

**临键锁（Next-Key Lock）**：

- 它是 **行锁（Record Lock） + 间隙锁（Gap Lock）** 的组合。它既锁住索引记录本身，也锁住该索引记录之前的间隙。

其中**MVCC**的意思是多版本并发控制。指维护一个数据的多个版本，使得读写操作**没有冲突**，

它的底实现主要是分为了**三个部分**，第一个是**隐藏字段**，第二个是**undo_log**日志，第三个是**read_View**读视图

**隐藏字段**是指:在mySql中给每个表都设置了**隐藏字段**，有一个是tx_id(**事务id**)，记录每一次操作的事务id，是自增的;

另一个字段是roll_pointer(**回滚指针**)，指向上一个**事务版本**的记录地址

undo_log主要的作用是**记录**回滚日志，**就是老版本数据**，在内部会形成一个**版本链**，在多个事务并行操作某一行记录，记录不同事务修改数据的版本，**通过roll-pointer指针形成一个链表**。

readView读视图解决的是一个**事务查询选择版本**的问题，在内部定义了一些匹配规则和当前的一些事务id**判断**该访问哪个**版本**的数据。不同的隔离级别**快照读**是不一样的，最终的访问的**结果不一样**。如果是r隔离级别，每一次执行快照读时生成ReadView，如果是rr隔离级别仅在事务中**第一次执行快照读时**生成ReadView，后续复用。

# 说一下主从同步的原理?

MySQL主从复制的核心就是**二进制日志bin_log**,记录所有数据库的修改操作。记录的是 SQL 语句的逻辑修改操作。二进制日志记录了所有的 DDL语句和 DML语句具体的主从同步过程大概的流程是这样的:

1.Master 主库在事务提交时，会把数据变更记录在二进制日志文件 BinLog 中。

2.从库读取主库的二进制日志文件 BinLog，写入到从库的中继日志 Relay Log

3.slave重做中继日志中的事件，将改变反映它自己的数据。

# 你们项目用过分库分表吗

业务介绍
1，根据自己简历上的项目，想一个数据量较大业务(请求数多或业务累积大)
2，达到了什么样的量级(单表1000万或超过20G)
·具体拆分策略
1，水平分库，将一个库的数据拆分到多个库中，解决海量数据存储和高并发的问题
2，水平分表，解决单表存储和性能的问题
sharding-sphere、mycat
3，垂直分库，根据业务进行拆分，高并发下提高磁盘10和网络连接数
4，垂直分表，冷热数据分离，多表互不影响

# 讲解下 DDL DML DCL

**DDL (Data Definition Language数据定义语言)**

职责: **定义和管理数据库结构本身**。它关注的是数据库的“骨架”或“蓝图”

操作对象: 数据库、表、视图、索引、存储过程、函数、触发器等**数据库对象**。

**隐式提交**:最重要的特性!执行大多数 DDL 语句
(如 CREATE,ALTER, DROP,TRUNCATE)会立即隐式提交当前事务。这意味着 DDL 操作**无法回滚**。



**DML (Data Manipulation Language -数据操纵语言)**

职责: 对数据库表中的实际数据进行增、删、改、查操作。它关注的是数据库的“内容”操作对象是表中的行，DML 操作(INSERT,UPDATE,DELETE)通常会触发定义在表上的DML **触发器**。

**DCL (Data Control Language -数据控制语言)**

**职责**: **控制对数据库及其对象的访问权限和安全性。它关注的是“谁可以做什么”，操作对象是数据库中的用户，授予用户或角色对特定数据库对象的操作权限。**也是隐式提交的
授权(GRANT):授予用户或角色对特定数据库对象(如表、视图、存储过程)执行特定操作(如 SELECT, INSERT, UPDATE, DELETE,EXECUTE)的权限

#  MySQL 中一条查询 SQL是如何执行的?

1、连接器:验证客户端权限

2、解析器:识别 SELECT、FROM、WHERE 关键词

3、优化器:选择主键索引(假设 id 是主键)

4、执行引擎:调用 InnoDB 索引查询接口

5、InnoDB

- 在缓冲池查询页数据
- 通过聚簇索引 B+Tree 定位行
- 返回行数据

6、执行引擎:组装结果集返回客户端

# 如何查看 sql 的执行计划（Explain）

在MySql中查看sql语句执行句话需要在语句前加上explain命令实现。、

需要查看的字段：type、key(实际索引)、key_len、rows、Extra(关键)、possible_keys(可能使用的索引)

- **type**
  表示**表的访问类型**，是**判断查询效率的核心指标**。常见值从优到差为：
  `system` > `const` > `eq_ref` > `ref` > `range` > `index` > `ALL`
  - `ALL` **表示全表扫描**，性能最差，需优化；
  - **system**：
  - **说明**：`const` 类型的特殊情况，指表中只有**一行数据**（如系统表）。
  - **效率**：最高效，无需搜索，直接获取唯一行。
  - **const**
    - **说明**：通过**主键**或**唯一索引**与常量值匹配，最多返回**一行结果**。
    - **示例**：`WHERE id = 123`（`id` 是主键）。
    - **效率**：非常高效，MySQL 可通过索引直接定位行。
- `range` 表示范围查询（如 `where id > 10`），性能较好；
  - `r**ef`/`eq_ref` 表示使用索引匹配，性能优秀**。
  - `index`
    - **说明**：扫描**整个索引树**（全索引扫描），而非表数据。
- **key**
  实际使用的索引名称。若为 `NULL`，说明未使用任何索引，可能需要添加合适的索引。
- **key_len**
  表示**索引使用的字节长度**，值越小说明索引利用越充分（如联合索引只使用了部分字段时，长度会更短）。
- **rows**
  预估需要扫描的行数，值越小越好。该值是 JVM 基于统计信息的估算，并非实际行数，但能反映查询的大致效率。
- **Extra**
  包含**额外的关键**信息，常见重要值：
  - `Using index`：使用了覆盖索引（无需回表查询数据），性能极佳；
  - `Using where`：需在索引扫描后用 `WHERE` 过滤数据，可能存在优化空间；
  - `Using filesort`：需额外排序（未利用索引排序），性能较差；
  - `Using temporary`：需创建临时表（如分组、去重时），性能损耗大。
- **possible_keys**
  可能会使用的索引列表，但实际是否使用需看 `key` 字段。若该字段为空，说明没有可用索引，需考虑新增索引。

# union 和 unionAll 区别（**聚合查询**）

- UNION:合并结果后**自动去重**，多了一个去重步骤。还会按**首列**排序。
- UNION ALL:合并结果**保留所有**记录(包括重复数据)。

<img src="D:\在图片\MySQL\004.png" style="zoom:50%;" />

- UNION 和 UNION ALL 连接的查询必须有相同数量的列
- 对应列的数据类型必须兼容
- 结果集的列名取自第一个 SELECT 语句

# inner join、left join、right join 

- 组合两个表中的记录，返回关联字段相符的记录，也就是返回两个表的交集
- 左(外)连接，左表(a_table)的记录将会**全部表示**出来，而右表(b_table)只会显示**符合搜索条件**的记录。右表记录不足的地方均为NULL。
- 右(外)连接，左表(a_table)只会显示符合搜索条件的记录，而右表(b_table)的记录将会全部表示出来。左表记录不足的地方均为NULL

# having 和 where 的区别

可以结合使用，多道过滤提高效率。

<img src="D:\在图片\MySQL\005.png" style="zoom:50%;" />

**执行时机不同**

- WHERE 在**分组前**过滤数据
- HAVING 在**分组后**过滤数据，可二次筛选。

**使用场景不同**

- WHERE用于过滤行
- HAVING用于过滤分组，搭配group by

**聚合函数：**

- WHERE不能直接使用聚合函数,结合group by使用聚合函数。
- HAVING可以使用聚合函数

# MySQL中的IN 和EXISTS 子句有什么区别?

**IN**和**EXISTS**都是子查询的运算符，但是执行逻辑和性能有区别。

IN会在查询到结果集后会存储子查询的结果集，而EXISTS只是判断是否存在，不存储结果，且在查询到第一条匹配数据后就会终止。

<img src="D:\在图片\MySQL\006.png" style="zoom:50%;" />

# MySQL一般如何处理NULL值，对性能有什么影响？

 MySQL对`NULL`有一套特定的处理规则（特殊比较、聚合忽略等）。`NULL` 在MySQL中表示“未知“它与空字符串(`''`)或`0`是**不同**的概念，在`ORDER BY`排序中，**`NULL`值默认被视为最小值**。Null在可变字符串列(varchar)中占据1bit，相较于空字符串（"")空间更少。

它对性能的影响需要具体分析**：`NULL`能被索引**，`IS NULL`条件**可以利用索引**高效查询找到这些行，

`COUNT(列)`（统计列中非null的值数量，需要逐行检查）比`COUNT(*)`（统计表中**所有行的数量**）所以略慢，在可变长列存储上`NULL`可能更省空间。关键是在设计表结构和编写查询时要正确理解`NULL`的含义和使用场景。

# MySQL中的表空间是什么，它的作用是什么?

MySQL的**表空间（Tablespace）是存储表数据、索引等内容的物理文件**。它是数据库在磁盘上的实际存储单元，由存储引擎（如InnoDB）管理

作用是**存储表的行数据和索引**，按需分配**管理磁盘空间**并支持**事务和性能(**如ACID)。

# 在MySQL中，如何优化ORDER BY

在 MySQL 中优化 ORDER BY查询的核心思路是**避免文件排序**(Filesort)，利用索引直接返回有序数据。

1.利用**索引**覆盖所有排序的列(最高效)，在索引中包含 ORDER BY的列，使 MySQL **直接从索引中读取有序数据**,如：让索引idx name 覆盖了ORDER BY的列，查询直接使用索引返回有序结果,

2.WHERE + ORDER BY 联合优化，创建包含 WHERE 条件和 ORDER BY 列的复合索引。索引同时满足过滤(user id)和排序(order date)避免**临时表**排序。

3.**使用 LIMIT 减少排序量**，LIMIT配合索引可提前终止排序。

4.**避免**排序字段**计算**,索引不存储计算值，对列使用函数或计算会导致索引失效。

5,调整排序缓冲区大小。：临时设置(全局需重启)
SET SESSION sort_buffe,_size = 4*1024*1024;

# MySQL 中的 GROUP BY 与DISTINCT 有何区别?

在 MySQL 中,GROUP BY和 DISTINCT 都处理数据的唯一性

**DISTINCT**会确保 SELECT 语句返回的结果集中所有列的**组合值**都是唯一的。它作用于整个选定的列列表。结果会**返回一个列表**，其中每一行(由所有选定列的值组成)都是唯一的。如果指定了多个列，则这些**列的组合值唯一**。可以用在**聚合函数**内部，会在聚合函数**计算前**对列的值去重

**GROUP BY (分组**)会将数据集根据一个或多个列的值分成不同的组。其主要目的是为了对每个组应用聚合函数进行汇总计算(如计数、求和、平均值、最大值、最小值)结果是为**每个唯一的组**返回一行。GROUP BY的核心就是为了和聚合函数一起使用。

**DISTINCT**：**目的**单纯去重，仅返回唯一不同的值，不涉及计算；

**GROUP BY**：**分组 + 聚合计算**（如 `SUM()`, `COUNT()`, `AVG()` 等），**目的**是按某列分组后统计汇总数据

# MySQL中，如何使用和优化LIMIT 子句进行分页?

LIMIT为了限制结果的行数，优化时可以使用索引覆盖，来**确保ORDER BY使用索引**，避免使用select*否则会导致全表扫描，**避免大offset**，使用where代替，：当offset超过1000时性能会显著下降

# 百万级别(海量)数据的 Excel如何快速导入到数据库中

首先，**数据正确性**问题，读取和导入过程中会有各种潜在的问题，我们需妥善处理各类**异常情况**，在插入数据前，我们先进行格式检查，然后在插入过程中处理异常情况，如果单挑数据插入失败，可以进行尝试二次插入，多次插入失败需要记录日志，方便后续的审核和重新插入数据。还要注意数据重读的情况，可以采取**唯一约束**的方式去处理也要记录日志。

其次就是内存溢出问题，不能一次性将数据读取到内存，分批处理可以使用Apache POl的**事件模型(SAX)**来处理 Excel,他不会将整个文件加载到内存，而是一行行的读取。

百万级数据处理可能遇到性能瓶颈，采用多线程去处理，可以分为读线程和写线程。

# 当给第三方提供接口调用，需要注意哪些事情?

**注意数据格式统一**使用json格式。还有的接口需要做到**优雅降级**，在高负载时关闭非核心功能。考虑敏感**数据的脱敏**，比如apikey，以及对**参数进行校验**，输入的参数一定要校验和防护。对第三方**接口一定要限流**。

