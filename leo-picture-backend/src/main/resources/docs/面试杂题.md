#### **面向对象的特征**

#### **final关键字的作用**

#### **Java17的新特性有哪些**

#### **什么是虚拟线程？它和普通的线程有什么区别吗？**

#### **== 和 Equlas的区别等**

**面向对象特征**

**答案：** "三大特征搭积木"

- **封装**：把东西装盒子里（private属性+public方法）
- **继承**：子类复用父类能力,达到代码复用的目的。（extends关键字）
- **多态**：同一方法不同实现（父类引用指向子类对象）

**final关键字**

**答案：** "Java里的'最终'警告牌"

- **修饰类**：这个类绝育了（不能被继承），比如String类
- **修饰方法**：这个方法锁定了（不能重写），比如模板方法
- **修饰变量**：这个变量定死了（基本类型值不变，引用类型指向不变）

**Java17新特性**

**答案：** "2021年发布的LTS版本亮点："

- **密封类**：精确控制继承权限

- **Switch模式匹配**（预览）：

- **Switch模式匹配**（预览）：

**虚拟线程（协程）**

**回答**：也就是说虚拟线程 是 Java 引入的一种轻量级并发单元，可以让一个操作系统线程运行数千个虚拟线程，虚拟线程阻塞后，JVM会挂起，让OS线程继续执行其他虚拟线程？这可以让java用同步代码跑出更高的性能和更低的资源消耗是吗。

区别：

- **普通线程**：1个OS线程承载1个Java线程
- **虚拟线程**：1个OS线程承载数千虚拟线程

虚拟线程（Virtual Threads） 是 Java 引入的 **轻量级并发单元**，允许开发者用 **同步代码风格** 写出 **高并发、低资源消耗** 的应用程序，特别适合 **I/O 密集型任务**（如网络请求、数据库访问）。

**核心特点**：

**轻量级**

- 一个 **操作系统线程（OS Thread）** 可以运行 **数千个虚拟线程**，而传统 Java 线程（平台线程）是 **1:1 绑定 OS 线程**，资源消耗大。

**自动调度**

- 当虚拟线程遇到 **阻塞操作**（如 `Thread.sleep()`、I/O 等待），JVM 会自动挂起它，并让 **底层 OS 线程去执行其他虚拟线程**，避免资源浪费。

**同步编程，异步性能**

- 开发者仍然可以用 **传统的 `Thread` 和同步代码**（如 `synchronized`、`wait/notify`），但底层实现了类似 **异步/协程** 的高效调度。

**总结**

**虚拟线程让 Java 用同步代码跑出异步性能，高并发 I/O 场景下，资源消耗降低 100 倍！**

**== 和 equals 区别**

**答案：** "==看身份证，equals看内涵"

- **==**：比较内存地址（是否是同一个对象）
- **equals**：默认同==，但可重写（如String比较内容），String类默认重写了equals方法





#### HashMap的结构，HashMap的put流程，HashMap冲突等

#### concurrentHashMap概念

#### 其他的集合用到哪些？对比一下使用的场景？

**put流程七步走：**

1. 计算key的hash值（高低位异或）
2. 找桶位置：(n-1) & hash
3. 桶为空 → 直接插入新节点
4. 桶不为空：
   - key相同 → 覆盖值
   - 链表 → 尾插法（JDK8）
   - 红黑树 → 树节点插入
5. 链表长度>8 → 转红黑树（需数组长度>=64）
6. 扩容检查：size > threshold
7. 扩容两倍并重. 扩容两倍并重哈希

**concurrentHashMap**：

设计哲学**： **分段锁 + CAS**（JDK7） → **CAS + synchronized 精细化锁（JDK8+）

**2. JDK7 vs JDK8 实现对比**

| **版本** | **数据结构**     | **锁机制**                         | **并发度**           |
| -------- | ---------------- | ---------------------------------- | -------------------- |
| JDK7     | 分段数组+链表    | Segment 分段锁（ReentrantLock）    | 默认16段，不可扩容   |
| JDK8+    | 数组+链表/红黑树 | CAS + synchronized（锁链表头节点） | 动态扩容，锁粒度更细 |

**JDK8 改进原因**：

- 分段锁的**内存开销大**
- 链表长度超过8转红黑树（避免退化）
- 降低锁粒度到单个链表头节点

**3. JDK8 核心实现细节**

**1. 关键属性**

```java
Javatransient volatile Node<K,V>[] table; // 哈希桶数组
private transient volatile int sizeCtl; // 控制标识符（扩容阈值等）
```

**2. put 流程（简化版）**

1. **计算 hash**：`(h ^ (h >>> 16)) & 0x7fffffff`
2. **无锁初始化表**：CAS 操作创建数组
3. **定位桶位置**：`(n - 1) & hash`
4. 插入节点
   - 桶为空 → CAS 插入
   - 桶不为空 → synchronized 锁住链表头节点
     - 链表 → 尾插法
     - 红黑树 → 树节点插入
5. **检查扩容**：超过阈值触发 transfer()

**3. 线程安全保证**

- **读操作**：完全无锁（volatile 变量读）
- 写操作
  - 空桶 → CAS
  - 非空桶 → synchronized 锁链表头
- **扩容**：多线程协同迁移（每个线程处理一部分桶）



#### Redis的某个类型的结构和用途，底层结构，什么场景用什么类型？Redis的基础类型有哪些？

**一、Redis 数据类型与底层结构**

**1. 5种基础数据类型**

| **类型**   | **底层结构**         | **特点**                       | **典型场景**                   |
| ---------- | -------------------- | ------------------------------ | ------------------------------ |
| **String** | SDS (简单动态字符串) | 二进制安全，可存文本/数字/图片 | 缓存、计数器（INCR）、分布式锁 |
| **List**   | 双向链表 + 压缩列表  | 有序，支持左右插入弹出         | 消息队列、最新消息排行         |
| **Hash**   | 字典 + 压缩列表      | 字段-值映射存储                | 存储对象（用户信息、商品详情） |
| **Set**    | 字典 + 整数数组      | 无序去重                       | 共同关注、抽奖去重             |
| **ZSet**   | 跳表 + 压缩列表      | 有序且去重                     | 排行榜、延迟队列               |

**特殊类型**：

- **Bitmaps**：位操作（用户签到）
- **HyperLogLog**：基数统计（UV统计）
- **Streams**：消息流（类似Kafka）

#### Redis的持久化机制？持久化时机选择？持久化流程？它们都有哪些缺点？

**二、持久化机制**

**1. RDB (快照)**

**原理**：

- 定时生成内存数据的二进制快照（`dump.rdb`）
- **SAVE**（阻塞） vs **BGSAVE**（后台fork子进程）

**配置**：

```
Bashsave 900 1      # 900秒内至少1次修改触发
save 300 10     # 300秒内至少10次修改
```

**优点**：

- 恢复速度快
- 文件紧凑（适合备份）

**缺点**：

- 可能丢失最后一次快照后的数据
- 大数据量时fork耗时

**2. AOF (追加日志)**

**原理**：

- 记录所有**写命令**（文本协议格式）
- 支持三种同步策略：
  - **always**（每条同步，安全但慢）
  - **everysec**（每秒同步，默认）
  - **no**（由操作系统决定）

**重写机制**：

- 压缩AOF文件（`BGREWRITEAOF`）
- 生成新文件替换旧文件

**优点**：

- 数据丢失风险低（everysec最多丢1秒）
- 可读性强（可通过AOF恢复数据）

**缺点**：

- 文件体积大
- 恢复速度慢

**3. 混合持久化（Redis 4.0+）**

**原理**：

- RDB快照 + AOF增量日志
- 重启时先加载RDB，再重放AOF

**配置**：

```
Bash
aof-use-rdb-preamble yes
```

**最佳实践**：

- 主节点开RDB + AOF
- 从节点开RDB

#### Redis的内存淘汰机制？Redis内存满了怎么办？LRU和LFU的有什么区别？

**三、内存淘汰策略**

**1. 6种淘汰策略**

| **策略**             | **规则**                | **适用场景**          |
| -------------------- | ----------------------- | --------------------- |
| `noeviction`（默认） | 拒绝写入，只读          | 数据绝对不能丢失      |
| `allkeys-lru`        | 淘汰最近最少使用的键    | 热点数据分布均匀      |
| `volatile-lru`       | 只淘汰设过期时间的LRU键 | 部分数据长期有效      |
| `allkeys-random`     | 随机淘汰任意键          | 无明确访问模式        |
| `volatile-random`    | 随机淘汰设过期时间的键  | 混合使用持久/临时数据 |
| `volatile-ttl`       | 优先淘汰剩余时间短的键  | 短期临时数据          |

**2. LRU vs LFU**

| **对比项** | **LRU**                        | **LFU**                        |
| ---------- | ------------------------------ | ------------------------------ |
| **依据**   | 最近访问时间                   | 访问频率 + 时间衰减            |
| **优点**   | 实现简单                       | 更精准识别热点数据             |
| **缺点**   | 可能误杀突发访问的冷数据       | 占用更多内存（需记录频率）     |
| **配置**   | `maxmemory-policy allkeys-lru` | `maxmemory-policy allkeys-lfu` |

**Redis为什么快？**

✅ 内存操作 + IO多路复用 + 单线程无锁

**Q2: 如何保证缓存与数据库一致性？**

✅ 先更新DB → 删除缓存（延迟双删兜底）

#### 项目使用G1 垃圾回收器的核心作用：平衡 “吞吐量” 和 “延迟”

可以高效处理 “大对象”，避免内存碎片，G1 通过 “Region” 机制（将内存划分为多个大小相等的独立区域）**，专门为大对象分配 “Humongous Region”（巨型区域），回收时会优先整理这些区域，确保图片等大对象能高效回收。可以减少 OOM**（内存溢出）风险（G1 的碎片控制更好，大对象分配更稳定）

图片上传和预览对接口响应延迟敏感（用户操作不能卡顿）。**G1 在控制延迟的同时，通过多线程并行回收**、增量回收（每次回收一部分内存），减少对业务线程的阻塞时间

项目中，用户上传图片、实时预览等操作需要低延迟（比如响应时间要求在 100ms 内）。若用 Serial GC（单线程回收）或 Parallel GC（多线程但可能长时间停顿），可能出现 “GC 时服务卡住几百毫秒” 的情况。

G1 的 “垃圾优先” 策略：通过维护每个 区域(Region) 的 “垃圾占比”，优先回收垃圾多的区域（耗时短、收益高），同时允许开发者设置**最大停顿时间目标**（如 `-XX:MaxGCPauseMillis=20`，即 GC 停顿不超过 20ms），确保用户操作时不会因 GC 产生明显卡顿。

#### 过滤器和拦截器的区别

**工作层面**：

- 过滤器(Filter)是基于Servlet规范的，工作在Web容器层面
- 拦截器(Interceptor)通常是框架提供的，工作在应用层面

**作用范围**：

- 过滤器可以过滤所有请求(静态资源、Servlet等)
- 拦截器通常只拦截Controller请求

**依赖关系**：

- 过滤器不依赖Spring等框架
- 拦截器通常依赖框架实现

**执行时机**：

- 过滤器在请求进入Servlet前和响应返回客户端前执行
- 拦截器在**Controller**方法前后执行

**实现方式**：

- 过滤器实现javax.servlet.Filter接口
- 拦截器实现框架特定接口(如HandlerInterceptor)

#### Cookie和Session的区别

1. **存储位置**：
   - Cookie存储在客户端浏览器中
   - Session存储在服务器端
2. **安全性**：
   - Cookie存在浏览器，安全性较低，容易被篡改
   - Session较安全，敏感信息存储在服务器
3. **存储大小**：
   - Cookie单个大小限制约4KB，每个域名下数量有限制
   - Session理论上无大小限制
4. **生命周期**：
   - Cookie可设置长期有效
   - Session通常在用户关闭浏览器后失效
5. **性能影响**：
   - Cookie随每次请求发送，可能增加带宽消耗
   - Session存储在服务器，可能增加服务器内存压力

#### String、StringBuilder、StringBuffer的区别

String的不可变性确实意味着**String对象一旦创建，其内容就不能被修改**

**值不可修改**：String类内部使用`final char value[]`存储字符数据，且没有提供任何修改这个数组内容的方法

**类不可继承**：String类本身被声明为`final`，防止子类通过继承改变其行为

**状态不可变**：所有字段都是`private`且没有setter方法

**为什么常用String**

Java为String提供了**直接量语法**（双引号表示）和**运算符重载**（`+`连接）

StringBuilder需要显式实例化和方法调用。

1. **可变性**：
   - String不可变(immutable)
   - StringBuilder和StringBuffer可变
2. **线程安全**：
   - String天然线程安全(不可变)
   - StringBuffer线程安全(方法使用synchronized修饰)
   - StringBuilder非线程安全
3. **性能**：
   - String每次修改都创建新对象，性能差
   - StringBuilder性能最好(无同步开销，StringBuilder内部维护了一个**可变的字符数组**)
   - StringBuffer性能介于两者之间
4. **使用场景**：
   - String：少量字符串操作或需要不变性
   - StringBuilder：单线程下大量字符串操作
   - StringBuffer：多线程下大量字符串操作

#### map和flatMap

都是Stream中非常重要的中间操作，但它们的使用场景和目的有本质区别。

简单来说，核心区别是：

· map：**一对一的转换。 将一个元素转换为另一个元素。**
· flatMap：**一对多的转换，然后扁平化**。 **将一个元素转换为一个流，然后将所有这些流“拍平”连接成一个流**。

---

1. **map (映射)**

· 功能：接受一个函数作为参数，这个函数会被应用到流中的每一个元素上，并将其映射成一个新的元素。它产生的是一个1:1的映射。
· 函数接口：Function<T, R>，输入一个类型为T的元素，返回一个类型为R的元素。
· 返回值：Stream<R>
· 类比：就像工厂里的流水线，每个进来的零件（元素）经过一个加工站（map函数），出来一个改造后的新零件（新元素）。零件的数量没有变。

示例1：将字符串转换为大写

```java
List<String> names = Arrays.asList("alice", "bob", "charlie");
List<String> upperCaseNames = names.stream()
                                  .map(String::toUpperCase) // 将每个字符串映射为其大写形式
                                  .collect(Collectors.toList());
// 结果： [ALICE, BOB, CHARLIE]
// 输入3个元素，输出也是3个元素。
```

示例2：提取对象中的某个字段

```java
List<Person> people = ...; // 一个Person对象列表
List<String> names = people.stream()
                          .map(Person::getName) // 将每个Person对象映射为其名字字符串
                          .collect(Collectors.toList());
// 输入N个Person，输出N个String。
```

---

2. **flatMap (扁平化映射)**

· 功能：接受一个函数作为参数，这个函数会被应用到流中的每一个元素上，但这个函数的返回值必须是一个Stream。然后，flatMap会将这些返回的多个Stream“拍平”（合并）成一个新的Stream。
· 函数接口：Function<T, Stream<R>>，输入一个类型为T的元素，返回一个Stream<R>（一个流的元素）。
· 返回值：Stream<R>
· 类比：你有一个盒子列表（原始流），每个盒子里装着多个玩具（元素集合）。flatMap的作用是：打开每个盒子（映射成一个流），然后把所有玩具都倒进一个大箱子里（扁平化）。你最终得到的是一个包含所有玩具的流。

经典示例：将嵌套集合或包含流的元素“拍平”

```java
List<List<String>> listOfLists = Arrays.asList(
  Arrays.asList("a", "b"),
  Arrays.asList("c", "d"),
  Arrays.asList("e", "f")
);

// 如果我们用 map，会得到 Stream<Stream<String>>
List<Stream<String>> resultWithMap = listOfLists.stream()
                                               .map(Collection::stream)
                                               .collect(Collectors.toList());
// 结果是一个包含3个Stream的List，这不是我们通常想要的。

// 使用 flatMap
List<String> flatList = listOfLists.stream()
                                  .flatMap(Collection::stream) // 将每个List映射成一个Stream，然后合并所有Stream
                                  .collect(Collectors.toList());
// 结果： [a, b, c, d, e, f]
// 输入3个元素（List），输出6个元素（String）。
```

另一个常见示例：拆分字符串并将所有结果合并

```java
List<String> sentences = Arrays.asList("Hello world", "Java Stream API");
List<String> words = sentences.stream()
                             .flatMap(sentence -> Arrays.stream(sentence.split(" "))) 
                             // 将每个句子映射成一个单词流（Stream<String>），然后合并
                             .collect(Collectors.toList());
// 结果： [Hello, world, Java, Stream, API]
```

---

对比总结表

 **map**

-  一对一转换 
- 函数返回值 任意类型 R  Stream<R>
- 元素数量 输入输出数量相等 
- 适用场景 转换元素类型或提取字段 

 **flatMap:**

- 一对多转换再合并
- 函数返回值必须是一个Stream
- 输出数量通常大于输入数量
- 处理嵌套结构（如List<List<T>>），合并多个流

如何选择？

· 当你只是需要将流中的每个元素简单转换成另一个对象时，用 map。
· 当你需要转换一个元素，但这个转换操作会产生多个结果（一个集合或流），并且你想将这些结果全部合并到一个单一的流中时，用 flatMap。

#### CompletableFuture的实现原理

![](D:\在图片\面试题\02.png)

CompletableFuture有两个属性：volatile obiect **result**用来保存**future结果**，volatile completion **stack**是一个用**链表实现的栈**，保存了依赖当前future的后续动作。

初始的supplyAsync(额sing可)方法创建了一个CompletableFuture，每次thenApply都会创建一个completion，completion除了包含提供的lamda函数外，还有**两个指针**分别指向它的前置future和新的后续future，completion自身会加入前置future的栈中。

生存结构如下：

当一个supply任务完成后，会找自己依赖的future，通过future的栈找到下一个执行的completion然后执行，以此类推直到完成。

<img src="D:\在图片\面试题\04.png" style="zoom: 50%;" />

**为什么使用completableFuture**

“在我的云图库项目中，CompletableFuture 解决了三个关键痛点： 

**第一**，**completableFuture的链式调用API拥有拼装能力，省去了循环和一些状态判断，链式调用功能扩展时不需要重构线程池，只需要加一个thenAppl链**。它的allOfAPI用**链式调用**API很好用，进行多任务协作「拼成一组」，等全部完成才统计结果，`thenApply` 在任务完成后自动结果收集。这种拼装能力，用普通线程池要写一堆循环和状态判断，而 CompletableFuture 一行链式调用就搞定了。

**第二**，每个任务**自带异常隔离**，局部失败不影响全局，在云服务场景，网络抖动、图片格式错误太常见了。如果用传统线程池：

- 使用线程池的话一个任务抛异常，整个批量操作直接崩掉
- 用户看到的就是「上传失败」，连成功了几张都不知道而 CompletableFuture 给每个任务配了exceptionally去处理单future异常这样即使10张里失败3张，用户也能看到成功上传了7张。

 **第三**，它底层用了工作窃取机制，空闲的线自动帮忙碌线程**分担**任务，更少的线程**承载更高的并发**（给数据对比）。

通过**多线程**将批量上传拆解为独立的图片上传任务，**completableFuture**使用批量上传图片的时候**单任务失败不影响整体**单个图片上传失败不会中断批量操作，可以通过内置异常处理`exceptionally()`异常，被限制在单个Future范围内，不会传播到主线程。拥有非阻塞回调：避免轮询检查任务状态。并且**功能扩展时需要重构线程池**，而completableFuture只需要添加thenApply链

| 方案                  | 批量上传10张图片        | 错误处理           | 资源控制   | 代码复杂度     |
| --------------------- | ----------------------- | ------------------ | ---------- | -------------- |
| **顺序同步**          | 总时间=单张时间×10      | 一处失败全失败     | 不可控     | 简单           |
| **基础线程池**        | 并发执行(快)            | 需额外处理异常传播 | 需手动管理 | 中等           |
| **CompletableFuture** | 并发执行+优雅聚合(最快) | 内置隔离机制       | 完善的控制 | 中等(但更清晰) |

#### 单点登录这块怎么实现的

一处登录到处访问，只需要登录一次，就可以访问所有信任的应用系统

<img src="D:\在图片\面试题\05.png" style="zoom: 67%;" />

将传统的本地 Session 改为 Redis 存储的分布式 Session，确保**多服务**实例能**共享 Session 数据**。

用户在任一系统**登录后**，生成全局唯一的 Session ID（令牌），并将用户信息存入 Redis，同时在**客户端浏览器**保存该令牌。

用户**访问**其他系统时，携带令牌Cookie/Header，系统通过令牌从 Redis 中查询用户信息，验证登录状态后即可访问。

退出登录清除 Redis 中的令牌信息，使所有关联系统的登录状态失效。

#### java版本

##### java25

虽然 Scoped Values 听起来比 ThreadLocal 更高级，但它不能 100% 替代 ThreadLocal。如果你要在线程中共享不可变数据、尤其是使用了虚拟线程的场景，建议使用 Scoped Values;但如果线程中共享的数据可能需要更新，那么还是使用 ThreadLocal，要根据实际场景选择。

**紧凑源文件和实例主方法**

在 Java 25 中，Hello World 程序可以直接简写为 3 行代码!

新的 IO类
首先是 Java 25 在 java.lang 包中新增了 IO 类，提供更简单的控制台 IO操作:

```java
void main(){
Io.println("Hello, World!");
}
void main(){
 String name = Io.readln("请输入您的姓名:");
 IO.print("很高兴认识您，");
 Io.println(name);
           }
```

Java 的核心竞争优势在于它成熟完善的生态系统，但语法不够简洁;现在 Java 只要持续借鉴其他新兴编程语言的优秀设计和语法特性、给开发者提供平滑的技术升级路径，就还是会有很多开发者继续使用Java，就不会被别的语言取代。

#### DDD =Domain-Driven Design

**领域(问题域) 驱动 设计(软件设计)**

核心方法论：

领域通过领域模型驱动软件设计

MVC架构转为DDD架构是从 “按技术分层” 转向 “按业务领域划分边界”，重点在于梳理业务核心域、明确领域模型关系，并通过限界上下文隔离复杂度。

- **领域层（Domain）**：存放实体（Entity）、值对象（Value Object）、领域服务（Domain Service）。例如：
- **应用层（Application）**：协调领域层完成用例，不包含业务规则。例如原`PictureController`的上传接口逻辑，迁移为`PictureApplicationService`的`uploadPicture()`，负责调用领域层并处理事务、权限等横切关注点。
- **基础设施层（Infrastructure）**：提供技术能力支持，如原`CosManager`、`DynamicShardingManager`作为基础设施服务，通过接口（`FileStorageService`、`ShardingService`）供上层调用，隔离技术实现细节。
- **接口层（Interface）**：保留 Controller，负责接收请求、参数校验，调用应用层服务。

### 项目中棘手的问题？项目中的难点？

**图片上传的事务与资源一致性问题（业务逻辑层面）**

**问题背景**：图片上传涉及 “文件上传到 COS”“数据库记录图片信息”“更新空间容量统计” 三个步骤，任何一步失败都可能导致数据不一致（如文件已上传但数据库未记录，或容量统计错误）。

**解决思路**：

- 采用 Spring 的`TransactionTemplate`管理事务，确保 “数据库记录 + 空间容量更新” 的原子性（如`PictureServiceImpl`的`uploadPicture`方法）。
- 对文件上传结果进行校验，若数据库操作失败，通过`CosManager`删除已上传的文件，避免存储冗余。
- 对空间容量做预校验（上传前检查是否超过`maxSize`和`maxCount`），减少事务内的回滚场景。

**难点**：文件存储属于分布式资源，无法纳入数据库事务，需通过 “补偿机制”（失败时删除文件）保证最终一致性；同时要处理大文件上传中断的情况，避免部分上传的文件占用空间。



### **面试官**："请分享你在项目中遇到的一个技术难点？"

**你**：

"在我负责的图片管理系统中，图片上传功能是最复杂的模块之一。它的难点在于要同时处理**五种维度的复杂性**：

1. **多源上传支持** 系统需要同时支持：不同的图片上传模式，
   - 用户本地上传（MultipartFile）
   - 网络图片URL上传
   - 空间内图片更新替换 我通过**模板方法模式**抽象出通用上传流程，不同来源只需实现校验、文件名获取和文件处理三个抽象方法。
2. **空间额度并发控制** 团队空间有严格的额度限制（总条数+总大小），这里遇到了核心难点：
   - 分布式环境下多个用户同时上传到同一空间
   - 额度更新需要保证原子性
   - **数据库更新和COS文件上传的事务一致性** 
   - **我的解决方案**：

1. 跨系统事务一致性

   文件存储（COS）与数据库的事务协调

   - 文件上传成功后若数据库操作失败，需清理COS文件
   - 我实现了**补偿机制**：

1. **安全与合规设计**
   - 文件名重写防止路径遍历攻击
   - 图片格式强制校验
   - 敏感操作权限验证
2. **资源泄漏防护** 通过`try-finally`确保：
   - 临时文件必删除
   - 分布式锁必释放

💡 回答亮点解析

1. **结构化表达** 用"五种复杂性"构建清晰框架，展示系统化思维能力
2. **技术深度展示**
   - 分布式锁（Redisson实现细节）
   - 跨系统事务（补偿机制）
   - 模板方法模式落地
3. **量化成果** "日均20万+上传量"、"618零事故"体现业务价值
4. **难点层次递进** 从功能需求 → 技术难点 → 架构决策 → 业务价值
5. **代码片段点睛** 精选3-5行核心代码佐证技术方案

️ 注意事项

1. **准备追问预案**：
   - *面试官可能问*："为什么选Redisson而非Redis Lua实现锁？" *可答*："Redisson提供完善的看门狗机制和可重入特性，避免自研的维护成本"
2. **突出设计思维**： "我刻意将文件上传放在获取锁**之后**，因为上传耗时可能达数百毫秒，这样能将锁持有时间缩短85%"
3. **展示演进过程**： "第一版没有额度双重检查，压力测试时出现超额5%的情况。后来在SQL中加入条件判断才彻底解决"
4. **关联架构理念**： "这个方案实践了'失败优先'设计思想：先进行所有校验（权限/额度/格式），最后才执行不可逆操作"

这个案例能充分展示你处理**复杂业务场景**、**分布式系统设计**和**故障防护**的能力，是面试中非常有说服力的技术亮点。

Rdisson锁实现细节

**Redisson分布式锁实现细节深度解析**

我将详细解释项目中Redisson分布式锁的实现细节，这是系统并发的核心技术点：

一、锁的创建与配置

```Java
// 构建分布式锁实例
RLock lock = redissonClient.getLock("spaceLock:" + spaceId);

// 尝试获取锁（核心参数）
boolean locked = lock.tryLock(
    3,    // 等待时间：最多等待3秒获取锁
    10,   // 租期时间：锁持有时间10秒
    TimeUnit.SECONDS
);
```

参数设计考量：

| 参数         | 值   | 意义                           | 设计依据                                         |
| ------------ | ---- | ------------------------------ | ------------------------------------------------ |
| 等待时间     | 3秒  | 线程尝试获取锁的最大等待时间   | 平衡用户体验（响应快）与系统负载（避免线程堆积） |
| **租期时间** | 10秒 | **最关键参数**：锁自动释放时间 | 覆盖业务操作最长时间（8秒P99指标） + 2秒缓冲     |
| 单位         | 秒   | 时间单位                       |                                                  |

> **为什么租期不是永久？** 防止进程冻结导致死锁（如Full GC暂停），租期到期自动释放保证系统健壮性

二、底层实现机制

核心Redis数据结构：

```bash
# 锁存储结构
HSET spaceLock:123 
    "mode": "redisson_lock"  # 锁类型标识
    "UUID_01:thread_1": 1    # 锁持有者标识（客户端ID+线程ID）
    "leaseTime": 10000        # 租期时间（毫秒）
```

三、关键特性实现

1. 看门狗自动续期机制

```Java
// Redisson内部实现（简化）
private void scheduleExpirationRenewal() {
    Thread renewalThread = new Thread(() -> {
        while (!Thread.interrupted()) {
            // 每1/3租期时间续期一次
            Thread.sleep(leaseTime / 3); 
            // 执行Lua脚本延长锁时间
            redis.eval("if redis.call('hexists', KEYS[1], ARGV[2]) == 1 then " +
                       "redis.call('pexpire', KEYS[1], ARGV[1]); " +
                       "return 1; end; " +
                       "return 0;", 
                       Collections.singletonList(lockName), 
                       leaseTime, clientId);
        }
    });
    renewalThread.start();
}
```

- **续期策略**：异步线程每租期1/3时间续期一次（10秒租期 → 每3.3秒续期）
- **续期操作**：通过Lua脚本原子性延长锁过期时间

**性能优化点**

1. 锁粒度控制

```Java
// 按空间ID分组锁（非全局锁）
String lockKey = "spaceLock:" + spaceId;  // 不同空间完全并行
```

- 避免全局锁瓶颈（如`global_upload_lock`）
- 并发度 = 空间数量（实际业务中约1000+空间）

2. 锁持有时间最小化

```Java
// 优化前后对比
// 错误做法：整个上传流程在锁内（包含网络IO）
lock.lock();
try {
    uploadToCOS(content);  // 可能耗时数秒
    saveToDB(metadata);
} finally { lock.unlock(); }

// 正确优化：仅额度更新在锁内
UploadResult result = uploadToCOS(content);  // 锁外执行
lock.lock();
try {
    updateSpaceQuota(spaceId, result.size()); // 快速操作
} finally { lock.unlock(); }
```

**效果**：锁持有时间从平均800ms → 50ms，吞吐量提升16倍

#### 为什么选择Redisson？

**看门狗锁续期机制防止死锁，未来分布式扩展预留技术空间。**

遇到Full GC时，线程会挂起，获取锁的线程会无法释放锁

**死锁防护三重保障**：

| 机制             | ReentrantLock | Redisson | 效果                   |
| ---------------- | ------------- | -------- | ---------------------- |
| 自动续期         | ❌             | ✅        | 防止业务阻塞导致锁过期 |
| 线程崩溃自动释放 | ❌             | ✅        | 租期到期强制释放       |
| 客户端掉线检测   | ❌             | ✅        | Redis主动释放失效锁    |

**何时选择Redisson（单机环境）？**

| 场景                     | Redisson | ReentrantLock |
| ------------------------ | -------- | ------------- |
| 需要防止线程阻塞导致死锁 | ✅        | ❌             |
| 需要可视化监控锁状态     | ✅        | ❌             |
| 未来可能扩展为分布式     | ✅        | ❌             |
| 需要跨线程重入           | ✅        | ❌             |
| 超低延迟（纳秒级）       | ❌        | ✅             |

**性能对比（单机测试数据）**

| 指标               | Redisson锁    | ReentrantLock |
| ------------------ | ------------- | ------------- |
| 获取锁耗时（平均） | 0.3ms         | 50ns          |
| 最大吞吐量（TPS）  | 12,000        | 2,000,000     |
| 内存占用           | 高（需Redis） | 低            |

| 特性           | 纯Redis实现 | Zookeeper     | **Redisson**       |
| -------------- | ----------- | ------------- | ------------------ |
| 可重入锁       | ❌ 需自实现  | ✅ 原生支持    | ✅ 完整支持         |
| 自动续期       | ❌ 需自实现  | ❌ 无          | ✅ 看门狗机制       |
| 发布订阅通知   | ❌ 需自实现  | ✅ 原生支持    | ✅ 内置实现         |
| 客户端故障释放 | ❌ 需TTL     | ✅ session机制 | ✅ 租期到期自动释放 |
| **开发效率**   | ⭐⭐          | ⭐⭐⭐           | ⭐⭐⭐⭐               |
| **运维复杂度** | ⭐⭐⭐⭐        | ⭐⭐            | ⭐⭐⭐                |

#### 面试时，该基于 Redisson 回答还是基于 SETNX 讲述原理？

**答案是：两者结合，分层次回答。这是最能体现你技术深度的方式。**

**面试回答策略（黄金结构）**

**第一层：直击本质，展现原理深度（约 60% 篇幅）**

**开场白**：“分布式锁的核心思想是在一个所有进程都能访问的地方设置一个标志。基于 Redis 实现，最核心的思路就是使用 `SET` 命令的 `NX` 和 `PX` 参数。”**所有分布式进程都能看到且公认的“占位符”**（通常就是一个 Key-Value 键值对）。哪个客户端能成功设置这个键值对，就视为它获得了锁。使用 `SETNX` (SET if Not eXists) 命令。只有**当 key 不存在时**，才能设置成功。

- 如果返回 `1`，说明设置成功，客户端获取到锁。
- 如果返回 `0`，说明 key 已存在，获取锁失败。

**然后，详细阐述基础实现和问题：**

1. **加锁**：“使用 `SET lock_key unique_value NX PX 30000` 这条原子命令，一次性解决存在判断和设置过期时间，防止死锁。”
2. **解锁**：“使用 Lua 脚本先比较 `unique_value` 再执行 `DEL`，保证原子性，防止误删其他客户端的锁。”
3. **指出缺陷**：“但这个方案有个经典问题：如果业务逻辑的执行时间超过了锁的过期时间，锁会提前释放，导致多个客户端同时进入临界区。这就需要一种**锁续期**机制。”

**到此为止，你已经向面试官证明了你完全理解分布式锁的原理、实现和核心挑战。**

**第二层：引出方案，展现工程能力（约 30% 篇幅）**

**承上启下**：“在实际生产环境中，我们不会自己去重复实现和处理所有这些细节，比如续期、重入、等待这些复杂逻辑。通常会选用成熟的客户端库，比如 **Redisson**。”

**介绍 Redisson 的优势：**

- “它的 `RLock` 对象提供了类似 JDK 锁的 API，非常易用。”
- “它内部实现了 **看门狗机制**，会后台定时续期，完美解决了锁过期但业务未执行完的问题。”
- “它还支持**可重入锁**、**公平锁**等多种特性，并且内置了对 RedLock 算法的支持，用于提升 Redis 集群下的可靠性。”

**第三层：总结升华，展现架构思维（约 10% 篇幅）**

**总结**：“所以，我的理解是，**掌握基于 `SET NX PX` 和 Lua 的原理是基础，它帮助我们理解分布式锁的核心挑战；而在实际项目中，我们则优先选择像 Redisson 这样成熟、稳定的框架来提升开发效率和系统可靠性。”**

## Dubbo 支持哪些负载均衡策略？ 

1）**随机（Random）**：相当于随机选择一个服务提供者。适用于调用数比较均匀的场景。 

2）**轮询（Round Robin）**：按顺序轮询选择提供者。适用于请求量大且稳定的场景。

 3）**最少活跃调用数（Least Active）**：优先选择当前活跃调用数最少的提供者，能够有效避免请求集中到某个服务提供者。 

4）**一致性哈希（Consistent Hash）**：对于相同参数的请求总是发到同一提供者。适用于缓存等对请求的一致性要求高的场景。

**一致性哈希（Consistent Hash）**：一致性哈希的核心思想是,**将请求根据一定的规则（如参数哈希值）映射到固定节点上**。这种策略特别适用于分布式缓存场景，比如在 Redis Cluster 或者分布式文件系统中，因为它能够在提供者节点数量变化时，仍然保持相对高的请求命中率。

## **幂等性（Idempotency）**

**是指同一个操作执行一次或多次，产生的结果是完全一致的**