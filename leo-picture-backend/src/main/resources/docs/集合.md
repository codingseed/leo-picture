为什么做这个项目?实战大量新技术和商业应用场景

![](D:\在图片\集合\01.png)

# 算法复杂度分析

**1.什么是算法时间复杂度**
时间复杂度表示了算法的**执行时间与数据规模**之间的增长关系

**2.常见的时间复杂度有哪些?**
0(1)、0(n)、0(n^2)、0(logn)
速记口诀:常对幂指阶

**3.什么是算法的空间复杂度?**
表示算法占用的额外存储空间与数据规模之间的增长关系常见的空间复杂度:0(1),0(n),O(n ^2)

**时间复杂度分析**:来评估代码的**执行耗时**的

![](D:\在图片\集合\02.png)

<img src="D:\在图片\集合\03.png" style="zoom:50%;" />

**只要代码的执行时间不随着n的增大而增大，这样的代码复杂度都是O(1)**

<img src="D:\在图片\集合\04.png" style="zoom:50%;" />

<img src="D:\在图片\集合\05.png" style="zoom:50%;" />

**空间复杂度分析**:空间复杂度全称是渐进空间复杂度，表示算法**占用的额外存储空间**与数据规模之间的增长关系

<img src="D:\在图片\集合\06.png" style="zoom:50%;" />

我们常见的空间复杂度就是O(1),0(n),0(n ^2)，其他像对数阶的复杂度几乎用不到，因此空间复杂度比时间复杂度分析要简单的多。

# ArrayList

数组(Array)是一种用**连续的内存空间**存储**相同数据类型**数据的线性数据结构。

#### ArrayList底层的实现原理是什么

- ArrayList底层是用动态的数组实现的
- ArrayList初始容量为0，当第一次添加数据的时候才会初始化容量为10
- ArrayList在进行扩容的时候是原来容量的1.5倍，每次扩容都需要拷贝数组
- ArrayList在添加数据的时候：

1. ​		确保数组已使用长度(size)加1之后足够存下下一个数据
2. ​		计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用grow方法扩容(原来的1.5倍)
3. ​		确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。
4. ​		返回添加成功布尔值。

#### ArrayList list=new ArrayList(10)中的list扩容几次

该语句只是声明和实例了一个 ArrayList，指定了容量为 10，未扩容，没有触发一次grow()方法。

#### 如何实现数组和List之间的转换

数组转List ，使用JDK中java.util.Arrays工具类的**asList**方法

List转数组，使用List的**toArray**方法。无参toArray方法返回Object数组，传入初始化长度的数组对象，返回该对象数组

面试官再问:

- 用Arrays.asList转List后，如果修改了数组内容，list受影响吗，会。
- List用toArray转数组后，如果修改了List内容，数组受影响吗，不会。

再答:

- Arrays.asList转换list之后，如果修改了数组的内容，**list会受影响**因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，**最终指向**的都是**同一个内存地址**
- list用了toArray转数组后，如果修改了list内容，**数组不会影响**，当调用了toArray以后，在底层是它是**进行了数组的拷贝**，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响

#### ArrayList 和 LinkedList 的区别是什么?

**底层数据结构不同**：动态数组和双向链表

**操作数据效率**

ArrayList按照下标查询(数组的索引)的时间复杂度O(1)【内存是连续的，根据寻址公式】LinkedList不支持下标查询

查找(未知索引): ArrayList需要遍历，链表也需要链表，时间复杂度都是O(n)

**新增和删除**

​	ArrayList尾部插入和删除，时间复杂度是O(1);其他部分增删需要挪动数组，时间复杂度是O(n)

​	LinkedList头尾节点增删时间复杂度是O(1)，其他都需要遍历链表，时间复杂度是O(n)

**内存空间占用**

ArrayList底层是数组，内存连续，节省内存

LinkedList 是双向链表需要存储数据，和两个指针，更占用内存

**线程安全**

ArrayList和LinkedList都不是线程安全的如果需要保证线程安全，有两种方案:
在方法内使用，局部变量则是线程安全的
使用线程安全的ArrayList和LinkedList

LinkedList 相较于 ArrayList 的主要**优势**在于：

1. 插入和删除操作更高效（尤其是在中间位置），在**已知前驱节点（或后继节点）时的插入**时间复杂度可达到 O (1)，无需像 ArrayList 那样移动大量元素
2. 内存利用率更灵活，不需要预先分配连续的大容量内存空间，避免了数组扩容带来的**性能开销** 

#### 单向链表和双向链表的区别是什么

双向链表，顾名思义，它支持两个方向

- 每个结点不止有一个后继指针 next 指向后面的结点
- 有一个前驱指针 prev 指向前面的结点

对比单链表

- 双向链表需要额外的两个空间来存储后继结点和前驱结点的地址
- 支持双向遍历，这样也带来了双向链表操作的灵活性

#### 链表操作数据的时间复杂度是多少

查询操作：

查询头尾结点的时间复杂度是O(1)
平均的查询时间复杂度是O(n)
给定节点找前驱节点的时间复杂度为O(1)

增删操作：

头尾结点增删的时间复杂度为O(1)
其他部分结点增删的时间复杂度是 O(n)
给定节点增删的时间复杂度为O(1)

# HashMap

## 二叉树

二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。

二叉树每个节点的左子树和右子树也分别满足二又树的定义。

<img src="D:\在图片\集合\07.png" style="zoom:50%;" />

### 二叉搜索树

- 二叉搜索树(Binary Search Tree,BST)又名**二叉査找树，有序二叉树或者排序二叉树**，是二叉树中比较常用的一种类型二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值
- 没有键值相等的节点
- 通常情况下二叉树搜索的时间复杂度为O(logn)

### 红黑树

- 红黑树(Red Black Tree):也是一种**自平衡**的二叉搜索树(BST)，之前叫做平衡二叉B树(Symmetric Binary B
  Tree)
- 所有的红黑规则都是希望红黑树能够保证平衡
- 红黑树的时间复杂度:查找、添加、删除都是O(logn)

性质1:节点要么是红色,要么是黑色
性质2:根节点是黑色
性质3:叶子节点都是黑色的空节点
性质4:红黑树中红色节点的子节点都是黑色
性质5:从任一节点到叶子节点的所有路径都包含相同数目的**黑色节点**

<img src="D:\在图片\集合\08.png" style="zoom:50%;" />

- 查找:
  红黑树也是一棵BST(二叉搜索树)树，查找操作的时间复杂度为:O(log n)
- 添加先要从根节点开始找到元素添加的位置，时间复杂度O(log n)。添加完成后涉及到复杂度为O(1)的旋转调整操作。故整体复杂度为:O(log n)
- 删除:
  首先从根节点开始找到被删除元素的位置，时间复杂度O(logn)。删除完成后涉及到复杂度为O(1)的旋转调整操作。故整体复杂度为:O(log n)

### 散列表

- 在HashMap中的最重要的一个数据结构就是散列表在散列表中又使用到了红黑树和链表
- 散列表(Hash Table)又名**哈希表/Hash表**，是**根据键(Key)**直接访问在内存存储位置**值(Value)**的数据结构。s
- 它是**由数组演化而来**的，利用了数组支持按照下标进行随机访问数据的特性

**散列冲突**

实际的情况下想找一个散列函数能够做到对于不同的kev计算得到的散列值都不同几乎是不可能的,这就是**散列冲突**(或者哈希冲突，哈希碰撞，就是指多个key映射到同一个数组下标位置。

- 散列冲突又称哈希冲突，哈希碰撞
- 指多个key映射到同一个数组下标位置

**散列冲突-链表法(拉链)**

- 数组的每个下标位置称之为桶(bucket)或者槽(slot)
- 每个桶(槽)会对应一条链表
- hash冲突后的元素都放到相同槽位对应的链表中或红黑树中

## HashMap实现原理

HashMap的数据结构:底层使用hash表数据结构，即数组和链表或红黑树



当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标

存储时，如果出现hash值相同的key，此时有两种情况。

​	a.如果key相同，则覆盖原始值;

​	b.如果key不同(出现冲突)，则将当前的key-value放入链表或红黑树中

获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。

## HashMap的jdk1.7和jdk1.8有什么区别

JDK1.8之前采用的拉链法，数组+链表

JDK1.8之后采用数组+链表+红黑树，链表长度大于8且数组长度大于64则会从链表转化为红黑树

## HashMap的put方法的具体流程

<img src="D:\在图片\集合\09.png" style="zoom:50%;" />

1.判断键值对数组table是否为空或为null，是就执行resize()进行扩容(初始化)
2.根据键值key计算hash值得到数组索引
3.判断索引值value是否==null（table[i]==null），条件成立，直接新建节点添加
4.如果table[i]==null ,不成立
	4.1 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value

​	4.2 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对

​	4.3 遍历链表，链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操 	作，遍历过程中若发现key已经存在直接覆盖value

5.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold(数组长度*0.75)，如果超过，进行扩容。

<img src="D:\在图片\集合\10.png" style="zoom:50%;" />

## HashMap的扩容流程

<img src="D:\在图片\集合\11.png" style="zoom:50%;" />

第一次添加数据初始化数组长度为16，以后每次每次扩在添加元素或初始化的时候需要调用resize方法进行扩容容都是达到了扩容阈值(数组长度*0.75)

**负载因子为什么默认0.75？**

**数学依据**：泊松分布下，0.75时链表长度超过8的概率极低（小于千万分之一）

每次扩容的时候，都是扩容之前容量的2倍，**为什么扩容是2倍？**

答：

位运算优化：`newIndex = oldIndex + (hash & oldCap)` 只需一次与操作，效率极高。

均匀分布：2倍扩容保持哈希分布均匀性，减少冲突。

扩容之后，会新创建一个数组，需要把老数组中的数据动到新的数组中
	没有hash冲突的节点，则直接使用 e.hash &(newcap-1)计算新数组的索引位置
	如果是红黑树，走红黑树的添加
	如果是链表，则需要遍历链表，可能需要**拆分链表**，判断(e.hash & oldCap)是否为0，该元素的位置要么停留在原始位置，要么移
	动到原始位置+**增加的数组大小**这个位置上

并发扩容可能导致环形链表（JDK7）或数据丢失（JDK8）。

## hashMap的寻址算法

回首先计算对象的 hashCode()

再进行调用 hash()方法进行**二次哈希**，即hashcode值右移16位再异或运算，让哈希分布更为均匀

最后数组长度减一和哈希运算的**位与操作**(capacity-1)& hash 得到索引

### 为何HashMap的数组长度一定是2的次幂?

计算索引时效率更高:如果是2的n次幂可以使用位与运算代替取模扩容时重新计算索引效率更高:hash & oldCap ==0的元素留在原来位置，否则新位置=|日位置+oldCap

## hashmap在1.7情况下的多线程死循环问题

jdk7的的数据结构是:数组+链表在数组进行扩容的时候，因为链表是**头插法**

在进行数据迁移的过程中，有可能导致死循环

比如说，现在有两个线程

线程一:读取到当前的hashmap数据，数据中一个链表，在准备扩容时，线程二介入

线程二:也读取hashmap，直接进行扩容。因为是头插法，链表的顺序会进行颠倒过来。比如原来的顺序是AB，扩容后的顺序是BA，线程二执行结束。

线程一:继续执行的时候就会出现死循环的问题。

线程一先将A移入新的链表，再将B插入到链头，由于另外一个线程的原因，B的next指向了A，所以**B->A->B**,形成循环当然，JDK8将扩容算法做了调整，不再将元素加入链表头(而是保持与扩容前一样的顺序)，尾插法，就避免了idk7中死循环的问题。